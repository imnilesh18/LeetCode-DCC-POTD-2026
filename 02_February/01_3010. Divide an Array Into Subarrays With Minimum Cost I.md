# 3010. Divide an Array Into Subarrays With Minimum Cost I

<div align="center">

![Difficulty: Easy](https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge&logo=leetcode)

![Array](https://img.shields.io/badge/Topic-Array-blue?style=for-the-badge)
![Sorting](https://img.shields.io/badge/Topic-Sorting-blue?style=for-the-badge)
![Enumeration](https://img.shields.io/badge/Topic-Enumeration-blue?style=for-the-badge)

</div>

---

## üìù Problem Statement

You are given an array of integers `nums` of length `n`.

The **cost** of an array is the value of its **first** element. For example, the cost of `[1,2,3]` is `1` while the cost of `[3,4,1]` is `3`.

You need to divide `nums` into **3 disjoint contiguous subarrays**.

Return *the **minimum possible sum** of the cost of these subarrays*.

**Example 1:**

> **Input:** `nums = [1,2,3,12]`
> **Output:** `6`
> **Explanation:** The best possible way to form 3 subarrays is: `[1]`, `[2]`, and `[3,12]` at a total cost of `1 + 2 + 3 = 6`.
> The other possible ways to form 3 subarrays are:
> - `[1]`, `[2,3]`, and `[12]` at a total cost of `1 + 2 + 12 = 15`.
> - `[1,2]`, `[3]`, and `[12]` at a total cost of `1 + 3 + 12 = 16`.

**Example 2:**

> **Input:** `nums = [5,4,3]`
> **Output:** `12`
> **Explanation:** The best possible way to form 3 subarrays is: `[5]`, `[4]`, and `[3]` at a total cost of `5 + 4 + 3 = 12`.
> It can be shown that 12 is the minimum cost achievable.

**Example 3:**

> **Input:** `nums = [10,3,1,1]`
> **Output:** `12`
> **Explanation:** The best possible way to form 3 subarrays is: `[10,3]`, `[1]`, and `[1]` at a total cost of `10 + 1 + 1 = 12`.
> It can be shown that 12 is the minimum cost achievable.

## üîí Constraints

- `3 <= n <= 50`
- `1 <= nums[i] <= 50`

---

## üí° Approach

The problem asks us to divide the array into three contiguous subarrays. A crucial observation is that the **first subarray must always start at index 0**. This means `nums[0]` will always contribute to the total cost.

To minimize the total sum, we need to minimize the costs of the second and third subarrays. The cost of a subarray is determined solely by its first element. Therefore, we simply need to find the **two smallest elements** from the remaining part of the array (from index `1` to `n-1`).

If we pick the two smallest numbers from the remaining array as the starting points for the second and third subarrays, we effectively minimize the total cost. All other elements can be appended to any of these subarrays without affecting the cost.

### Steps:
1.  Initialize `score` with `nums[0]` (since the first element is mandatory).
2.  Iterate through the array starting from index `1`.
3.  Find the smallest (`firstMin`) and the second smallest (`secondMin`) elements in this range.
4.  The result is the sum of `score`, `firstMin`, and `secondMin`.

---

## üíª Solution Code

```cpp
// Intuition: The first element is fixed. To minimize the total cost, we essentially need to find the two smallest elements from the remaining array (index 1 to n-1) to start the 2nd and 3rd subarrays.
// Approach: Iterate through the array starting from index 1, maintaining the two smallest values found so far. Finally, return nums[0] + min1 + min2.
// Time Complexity: O(N), where N is the length of the array. We iterate through the array once.
// Space Complexity: O(1), as we only use a few variables for storage.

class Solution {
public:
    int minimumCost(vector<int>& nums) {
        int n = nums.size();
        int score = nums[0]; // The first element is always part of the cost

        // Initialize two minimums with the maximum possible integer value
        int firstMin = INT_MAX;
        int secondMin = INT_MAX;

        // Traverse from the second element to the end
        for(int i = 1; i < n; i++) {
            // Check if current element is smaller than the smallest found so far
            if(nums[i] < firstMin) {
                secondMin = firstMin; // Update second minimum
                firstMin = nums[i];   // Update first minimum
            } 
            // If not smaller than firstMin, check if it's smaller than secondMin
            else if(nums[i] < secondMin) {
                secondMin = nums[i];  // Update second minimum
            }
        }

        return score + firstMin + secondMin; // Return total minimum cost
    }
};

/*
*
* Dry Run
* Input: nums = [1, 2, 3, 12]
* n = 4, score = 1
*
* Iteration 1 (i=1):
* nums[1] = 2
* 2 < INT_MAX -> True
* secondMin = INT_MAX
* firstMin = 2
*
* Iteration 2 (i=2):
* nums[2] = 3
* 3 < 2 -> False
* 3 < INT_MAX -> True
* secondMin = 3
*
* Iteration 3 (i=3):
* nums[3] = 12
* 12 < 2 -> False
* 12 < 3 -> False
*
* Loop Ends.
* Return score + firstMin + secondMin
* Return 1 + 2 + 3 = 6
*
*/

```

---

## üóíÔ∏è Notes

* The problem simplifies to finding the 1st and 2nd minimums in a subarray.
* Sorting the subarray `nums[1...n-1]` would take `O(N log N)`, but a single pass `O(N)` is more efficient.
* The constraints are small (`n <= 50`), so even a less efficient solution would pass, but `O(N)` is optimal.

## üóùÔ∏è Key Insights

* **Fixed Start**: The constraint of contiguous subarrays essentially locks `nums[0]` as the first cost component.
* **Greedy Choice**: By greedily selecting the smallest available numbers as the start of the next partitions, we guarantee the minimum sum.
* **Single Pass Logic**: Finding the top 2 smallest numbers can always be done in a single traversal without sorting.

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
