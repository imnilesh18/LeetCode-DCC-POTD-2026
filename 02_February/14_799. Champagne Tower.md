# 799. Champagne Tower

<p align="center">
  <a href="https://leetcode.com/problems/champagne-tower/description/">
    <img src="https://img.shields.io/badge/LeetCode-799-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 799">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge&logo=appveyor" alt="Difficulty Medium">
  </a>
  <a href="./LICENSE">
    <img src="https://img.shields.io/badge/License-MIT-blue?style=for-the-badge&logo=microsoft" alt="MIT License">
  </a>
</p>

<p align="center">
  <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png" alt="Champagne Tower" width="500">
</p>

---

## üìù Problem Statement

We stack glasses in a pyramid, where the **first row** has **1 glass**, the **second row** has **2 glasses**, and so on until the 100th row. Each glass holds **one cup** of champagne.

Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)

For example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full.

Now after pouring some non-negative integer cups of champagne, return how full the `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed).

## ‚õìÔ∏è Constraints

- `0 <= poured <= 10^9`
- `0 <= query_glass <= query_row < 100`

## üè∑Ô∏è Tags

- `Dynamic Programming`
- `Simulation`
- `Recursion`
- `Memoization`

---

## üí° Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :--- | :--- |
| **1** | `poured = 1`, `query_row = 1`, `query_glass = 1` | `0.00000` | We poured 1 cup to the top glass. There is no excess liquid, so all glasses under it remain empty. |
| **2** | `poured = 2`, `query_row = 1`, `query_glass = 1` | `0.50000` | We poured 2 cups. The top glass fills (1 cup). The 1 cup excess splits equally (0.5 each) to the two glasses in row 1. |
| **3** | `poured = 100000009`, `query_row = 33`, `query_glass = 17` | `1.00000` | The glass is completely full. |

---

## üìò Explanation

This problem can be modeled as a simulation, but a direct simulation of pouring drop-by-drop is inefficient. Instead, we can think about the state of any specific glass based on its parents.

### Key Insights

1.  **Inverse Flow Logic**: Instead of pushing flow down, we can calculate how much flow a glass *receives* by querying its parents.
2.  **Parental Contribution**: A glass at position `(i, j)` receives champagne from two sources in the row above:
    -   Top-left parent: `(i-1, j-1)`
    -   Top-right parent: `(i-1, j)`
3.  **Overflow Calculation**: A parent only contributes if it has more than **1 cup** of liquid.
    -   The amount it overflows is `(total_liquid - 1)`.
    -   This overflow is split equally, so the child receives `(total_liquid - 1) / 2.0`.
4.  **Base Case**: The very top glass `(0, 0)` simply receives the initial `poured` amount.
5.  **Memoization**: Since many glasses share common ancestors, we use a 2D array `t[101][101]` to store the calculated inflow for each glass to avoid redundant calculations.
6.  **Final Result**: A glass can only hold 1 cup. If the calculation shows it received 1.5 cups, it holds 1.0 cup (and overflows the rest). Thus, the answer is `min(1.0, calculated_value)`.

### Approach

We implement a recursive function `solve(i, j)`:
1.  **Bounds Check**: If `i < 0` or `j` is out of valid bounds for row `i`, return 0.
2.  **Base Case**: If `i=0, j=0`, return `poured`.
3.  **Recursion**:
    -   Calculate flow from `up_left`: `(solve(i-1, j-1) - 1) / 2.0`.
    -   Calculate flow from `up_right`: `(solve(i-1, j) - 1) / 2.0`.
    -   If a calculated flow is negative (parent wasn't full), treat it as 0.
4.  **Memoize**: Store the sum `up_left + up_right` in `t[i][j]`.

---

## üíª Recursive Solution with Memoization (C++)

```cpp
// Intuition: Instead of simulating flow down, we recursively calculate how much liquid flows INTO a specific glass from its two parents.
// Approach: Top-down recursion with memoization (Dynamic Programming). A glass receives half of the overflow from its top-left and top-right parents.
// Time Complexity: O(R^2) where R is the query_row. We calculate the state for every glass in the pyramid above the target.
// Space Complexity: O(R^2) or O(101*101) for the memoization table.

class Solution {
public:
    double t[101][101]; // Memoization table to store total liquid reaching glass(i, j)
    
    // Recursive function to determine liquid reaching (i, j)
    double solve(int poured, int i, int j) {
        
        // Boundary check: row < 0 or column out of bounds
        if(i < 0 || j > i || j < 0)
            return 0.0;
        
        // Base case: The top glass receives all poured champagne
        if(i == 0 && j == 0)
            return t[i][j] = poured;
        
        // Return memoized value if already computed
        if(t[i][j] != -1)
            return t[i][j];
        
        // Calculate overflow contribution from top-left parent
        // Parent keeps 1, passes (val-1)/2. If val < 1, contribution is negative (handled below)
        double up_left  = (solve(poured, i - 1, j - 1) - 1) / 2.0;
        
        // Calculate overflow contribution from top-right parent
        double up_right = (solve(poured, i - 1, j) - 1) / 2.0;
            
        // If contribution is negative (parent wasn't full), set to 0
         if(up_left < 0)
            up_left = 0.0;
        
        if(up_right < 0)
            up_right = 0.0;
        
        // Store total incoming flow in the table and return
        return t[i][j] = up_left + up_right;
    }
    
    double champagneTower(int poured, int query_row, int query_glass) {
        // Initialize memoization table with -1
        for(int i = 0; i<101; i++) {
            for(int j = 0; j<101; j++) {
                t[i][j] = -1;
            }
        }
        
        // The glass holds max 1.0 cup, rest overflows. We want the amount currently held.
        return min(1.0, solve(poured, query_row, query_glass));
    }
};

/*
*
* Dry Run
* Input: poured = 2, query_row = 1, query_glass = 1
* Goal: Find liquid in glass (1, 1).
* * 1. Call solve(2, 1, 1).
* 2. Needs data from parents (0, 0) and (0, 1).
* 3. solve(2, 0, 1): Out of bounds (j > i), returns 0.0. -> up_right becomes 0.
* 4. solve(2, 0, 0): Base case, returns 2.0 (total poured).
* 5. Calculate flow from (0, 0) to (1, 1):
* Overflow = (2.0 - 1) / 2.0 = 0.5. -> up_left becomes 0.5.
* 6. Total flow into (1, 1) = up_left + up_right = 0.5 + 0.0 = 0.5.
* 7. Memoize t[1][1] = 0.5.
* 8. Result = min(1.0, 0.5) = 0.5.
*
*/
```

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/champagne-tower/description/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)