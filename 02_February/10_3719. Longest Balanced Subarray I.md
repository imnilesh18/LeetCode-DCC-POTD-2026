# 3719. Longest Balanced Subarray I

<div align="center">

<img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge&logo=leetcode" alt="Difficulty Medium" />
<img src="https://img.shields.io/badge/Time_Complexity-O(NÂ²)-blue?style=for-the-badge" alt="Time Complexity O(NÂ²)" />
<img src="https://img.shields.io/badge/Space_Complexity-O(N)-purple?style=for-the-badge" alt="Space Complexity O(N)" />

<br/>

<img src="https://img.shields.io/badge/Array-blue?style=flat-square" alt="Array" />
<img src="https://img.shields.io/badge/Hash_Table-green?style=flat-square" alt="Hash Table" />
<img src="https://img.shields.io/badge/Enumeration-orange?style=flat-square" alt="Enumeration" />

</div>

---

## ğŸ”— Problem Link

[**LeetCode: Longest Balanced Subarray I**](https://leetcode.com/problems/longest-balanced-subarray-i/)

---

## ğŸ’¡ Problem Statement

You are given an integer array `nums`.

A **subarray** is called **balanced** if the number of **distinct even** numbers in the subarray is equal to the number of **distinct odd** numbers.

Return *the length of the **longest** balanced subarray*.

**Example 1:**

```text
Input: nums = [2,5,4,3]
Output: 4
Explanation:
The longest balanced subarray is [2, 5, 4, 3].
It has 2 distinct even numbers [2, 4] and 2 distinct odd numbers [5, 3]. Thus, the answer is 4.

```

**Example 2:**

```text
Input: nums = [3,2,2,5,4]
Output: 5
Explanation:
The longest balanced subarray is [3, 2, 2, 5, 4].
It has 2 distinct even numbers [2, 4] and 2 distinct odd numbers [3, 5]. Thus, the answer is 5.

```

**Example 3:**

```text
Input: nums = [1,2,3,2]
Output: 3
Explanation:
The longest balanced subarray is [2, 3, 2].
It has 1 distinct even number [2] and 1 distinct odd number [3]. Thus, the answer is 3.

```

---

## ğŸ“ Constraints

* `1 <= nums.length <= 1500`
* `1 <= nums[i] <= 10^5`

---

## ğŸ§  Explanation & Approach

The problem asks for the longest contiguous subarray where the count of **unique** even numbers equals the count of **unique** odd numbers.

### Approach: Brute Force with Sets

Given the constraint `nums.length <= 1500`, an  solution is acceptable. The core idea is to explore every possible subarray and check if it is "balanced".

1. **Iterate Subarrays**: We use nested loops to generate all subarrays. The outer loop (`i`) fixes the starting point, and the inner loop (`j`) extends the subarray to the end.
2. **Track Distinct Numbers**: For each subarray starting at `i`, we maintain two hash sets (`unordered_set` in C++):
* `even`: Stores unique even numbers encountered so far in the current window.
* `odd`: Stores unique odd numbers encountered so far in the current window.


3. **Process Elements**: As we move `j` from `i` to `n-1`, we check if `nums[j]` is even or odd and insert it into the respective set. The set automatically handles duplicates, ensuring we only count distinct values.
4. **Check Condition**: At each step `j`, compare the sizes of the two sets (`even.size() == odd.size()`). If they are equal, the subarray `nums[i...j]` is balanced.
5. **Update Result**: Calculate the length of this balanced subarray (`j - i + 1`) and update the `maxLen` variable if this length is greater than the current maximum.

> **Note on Sliding Window**: While this problem looks like it could be solved with a Sliding Window (Two Pointers) approach, efficiently shrinking the window from the left is difficult. Removing an element from the left might not decrease the distinct count if that number appears elsewhere in the window. Tracking this frequency requires extra state (like a map), but since  works, the brute force enumeration is simpler and sufficient.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Iterate through all possible subarrays and use sets to count distinct even/odd numbers efficiently.
// Approach: Nested loops define the subarray boundaries. Hash sets track unique elements. Compare set sizes to find balanced subarrays.
// Time Complexity: O(N^2) - We iterate through all subarrays, and set insertions are average O(1).
// Space Complexity: O(N) - In the worst case, sets store all elements of the array.

class Solution {
public:
    int longestBalanced(vector<int>& nums) {
        int n = nums.size();
        int maxLen = 0;

        // Iterate through every possible starting index of the subarray
        for(int i = 0; i < n; i++) {
            unordered_set<int> even;
            unordered_set<int> odd;

            // Expand the subarray from index i to j
            for(int j = i; j < n; j++) {
                // Check parity and insert into the corresponding set to track distinct values
                if(nums[j] % 2 == 0) {
                    even.insert(nums[j]);
                } else {
                    odd.insert(nums[j]);
                }

                // If the count of distinct even numbers equals distinct odd numbers, update maxLen
                if(even.size() == odd.size()){
                    maxLen = max(maxLen, j - i + 1);
                }
            }
        }
        return maxLen;
    }
};

/*
*
* Dry Run
* Input: nums = [1, 2, 3, 2]
* n = 4, maxLen = 0
*
* Iteration i = 0 (Start at index 0, Value: 1):
* j = 0 (Val 1): odd={1}, even={}. Sizes: 1 != 0.
* j = 1 (Val 2): odd={1}, even={2}. Sizes: 1 == 1. Balanced! maxLen = max(0, 2) = 2.
* j = 2 (Val 3): odd={1, 3}, even={2}. Sizes: 2 != 1.
* j = 3 (Val 2): odd={1, 3}, even={2}. (2 is duplicate). Sizes: 2 != 1.
*
* Iteration i = 1 (Start at index 1, Value: 2):
* j = 1 (Val 2): even={2}, odd={}. Sizes: 1 != 0.
* j = 2 (Val 3): even={2}, odd={3}. Sizes: 1 == 1. Balanced! maxLen = max(2, 2) = 2.
* j = 3 (Val 2): even={2}, odd={3}. Sizes: 1 == 1. Balanced! maxLen = max(2, 3) = 3.
*
* Iteration i = 2 (Start at index 2, Value: 3):
* j = 2 (Val 3): odd={3}, even={}. Sizes: 1 != 0.
* j = 3 (Val 2): odd={3}, even={2}. Sizes: 1 == 1. Balanced! maxLen = max(3, 2) = 3.
*
* Iteration i = 3 (Start at index 3, Value: 2):
* j = 3 (Val 2): even={2}, odd={}. Sizes: 1 != 0.
*
* Loop ends. Return maxLen = 3.
*/

```

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/longest-balanced-subarray-i/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)