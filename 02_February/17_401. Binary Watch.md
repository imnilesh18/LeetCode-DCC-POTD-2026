# 401. Binary Watch

<p align="center">
  <a href="https://leetcode.com/problems/binary-watch/description/">
    <img src="https://img.shields.io/badge/LeetCode-401-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 401">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github" alt="Author">
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty">
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B" alt="C++">
</p>

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg" alt="Binary Watch" width="400">
</p>

## ðŸ“‹ Problem Statement

A binary watch has 4 LEDs on the top to represent the hours (**0-11**), and 6 LEDs on the bottom to represent the minutes (**0-59**). Each LED represents a zero or one, with the least significant bit on the right.

Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return *all possible times the watch could represent*. You may return the answer in **any order**.

The hour must not contain a leading zero.
* For example, "01:00" is not valid. It should be "1:00".

The minute must consist of two digits and may contain a leading zero.
* For example, "10:2" is not valid. It should be "10:02".

---

## ðŸ”’ Constraints

* `0 <= turnedOn <= 10`

---

## ðŸ§ª Examples

### Example 1
```
Input: turnedOn = 1
Output: ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
```

### Example 2
```
Input: turnedOn = 9
Output: []
```

---

## ðŸ’¡ Approach

The problem asks us to find all possible times where the total number of ON LEDs (bits set to 1) equals `turnedOn`.

Instead of trying to generate combinations of LEDs (which is complex), we can use a **Brute Force (Enumeration)** approach because the possible time space is very small:
1.  **Iterate through all possible hours**: The hour `HH` ranges from 0 to 11.
2.  **Iterate through all possible minutes**: The minute `MM` ranges from 0 to 59.
3.  **Count the set bits**: For each valid time pair `(HH, MM)`, we count the number of set bits (1s) in the binary representation of `HH` and `MM`. The LEDs on the watch correspond directly to these set bits.
4.  **Validate**: If the sum of set bits in `HH` and `MM` equals the given `turnedOn` integer, this is a valid time.
5.  **Format and Store**: Convert the `HH` and `MM` to a string format "HH:MM". Special care must be taken for minutes less than 10 to append a leading '0' (e.g., 5 minutes becomes "05").

This approach is efficient because the outer loop runs 12 times and the inner loop 60 times, resulting in a constant number of operations (720 iterations).

---

## ðŸ’» Solution Code

```cpp
// Intuition: Iterate through all possible times (0:00 to 11:59) and check if the total set bits equal turnedOn.
// Approach: Simple Enumeration (Brute Force) over hours and minutes.
// Time Complexity: O(1) - The loops run a fixed number of times (12 * 60 = 720 iterations).
// Space Complexity: O(1) - Ignoring the space required for the output vector.

class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> result;

        // Iterate through all valid hours (0-11)
        for (int HH = 0; HH <= 11; HH++) {

            // Iterate through all valid minutes (0-59)
            for (int MM = 0; MM <= 59; MM++) {
                
                // Check if total set bits in Hour and Minute equal the target
                if (__builtin_popcount(HH) + __builtin_popcount(MM) == turnedOn) {
                    string hour   = to_string(HH);
                    // Add leading zero for single-digit minutes
                    string minute = (MM < 10 ? "0" : "") + to_string(MM);
                    
                    result.push_back(hour + ":" + minute);
                }
            }
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: turnedOn = 1
* * Loop HH = 0 to 11:
* HH = 0 (0 bits set):
* Loop MM = 0 to 59:
* MM = 0 (0 bits) -> 0+0 != 1
* MM = 1 (1 bit)  -> 0+1 == 1 -> Valid -> Add "0:01"
* MM = 2 (1 bit)  -> 0+1 == 1 -> Valid -> Add "0:02"
* MM = 3 (2 bits) -> 0+2 != 1
* ...
* HH = 1 (1 bit set):
* Loop MM = 0 to 59:
* MM = 0 (0 bits) -> 1+0 == 1 -> Valid -> Add "1:00"
* ... and so on for all combinations.
*
*/
```

---

## ðŸ‘¨â€ðŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)

---

## ðŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/binary-watch/description/) for original content and copyright.**