# 190. Reverse Bits

<div align="center">

<a href="https://leetcode.com/problems/reverse-bits/description/">
    <img src="https://img.shields.io/badge/LeetCode-Easy-green?style=for-the-badge&logo=leetcode" alt="LeetCode Easy" />
</a>
<a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="C++" />
</a>
<a href="https://leetcode.com/tag/bit-manipulation/">
    <img src="https://img.shields.io/badge/Topic-Bit%20Manipulation-orange?style=for-the-badge" alt="Bit Manipulation" />
</a>

</div>

---

## üìù Problem Details

| Field | Detail |
| :--- | :--- |
| **Problem Link** | [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/description/) |
| **Problem Name** | 190. Reverse Bits |
| **Difficulty** | Easy |
| **Tags** | Bit Manipulation, Divide and Conquer |

---

## ‚ùì Problem Statement

Reverse bits of a given 32 bits unsigned integer.

**Note:**
- Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 1 above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.

---

## üß± Constraints

- `0 <= n <= 2^31 - 2`

---

## üîç Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :--- | :--- |
| **1** | `n = 00000010100101000001111010011100` | `964176192` (`00111001011110000010100101000000`) | The input binary string is reversed. |
| **2** | `n = 11111111111111111111111111111101` | `3221225471` (`10111111111111111111111111111111`) | The input binary string is reversed. |

---

## üí° Approach

The problem asks us to reverse the 32 bits of an integer. We can think of this like reversing a string or an array, but operating at the bit level.

**Algorithm:**
1.  Initialize a variable `result` to 0 to store the reversed bits.
2.  Iterate exactly 32 times (since standard integers are 32-bit).
3.  Inside the loop:
    * Shift the `result` to the left by 1 (`<< 1`) to make space for the new bit coming from `n`.
    * Extract the least significant bit (LSB) of `n` using the bitwise AND operator with 1 (`n & 1`).
    * Add this extracted bit to the LSB position of `result` using the bitwise OR operator (`|`).
    * Shift `n` to the right by 1 (`>> 1`) to process the next bit in the subsequent iteration.
4.  After the loop finishes, `result` will contain the bit-reversed value of `n`.

This method effectively "peels" bits off the end of `n` and pushes them onto the end of `result`, utilizing the left shift on `result` to move previous bits to higher positions, effectively reversing the order.

---

## üíª Solution Code

<details>
<summary>Click to view the C++ Solution</summary>

```cpp
// Intuition: Process bits from LSB of 'n' and push them to LSB of 'result', shifting 'result' left to reverse order.
// Approach: Iterate 32 times. Left shift result to make room, add LSB of n, then right shift n to process next bit.
// Time Complexity: O(1) - The loop runs exactly 32 times, regardless of the input value.
// Space Complexity: O(1) - We only use a single variable for the result.

class Solution {
public:
    int reverseBits(int n) {
        if (n == 0) return 0; // Base case for 0
    
        int result = 0; // Will store the reversed number
        for (int i = 0; i < 32; i++) {
            result <<= 1; // Create space at LSB of result
            
            // Extract LSB of n and add it to LSB of result
            result = (result | (n & 1));
            
            n >>= 1; // Move to the next bit of n
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: n = 13 (Binary for simplicity: 1101, assuming 4-bit loop instead of 32)
*
* i = 0:
* result << 1 -> result = 0 (0000)
* n & 1 = 1 (1101 & 0001) -> result | 1 = 1 (0001)
* n >> 1 -> n = 6 (0110)
*
* i = 1:
* result << 1 -> result = 2 (0010)
* n & 1 = 0 (0110 & 0001) -> result | 0 = 2 (0010)
* n >> 1 -> n = 3 (0011)
*
* i = 2:
* result << 1 -> result = 4 (0100)
* n & 1 = 1 (0011 & 0001) -> result | 1 = 5 (0101)
* n >> 1 -> n = 1 (0001)
*
* i = 3:
* result << 1 -> result = 10 (1010)
* n & 1 = 1 (0001 & 0001) -> result | 1 = 11 (1011)
* n >> 1 -> n = 0 (0000)
*
* Final Result: 11 (1011). 
* Note: For 13 (1101), reverse is 11 (1011) in 4-bit representation.
* In 32-bit, the logic remains identical, shifting through all zero padding.
*
*/

```

</details>

---

## üîë Key Insights

* **Bitwise Operators:** Mastering `&` (AND) to extract bits, `|` (OR) to set bits, `<<` (Left Shift) to move bits to higher significance, and `>>` (Right Shift) to move bits to lower significance is crucial.
* **Fixed Iteration:** Since the input type is a fixed 32-bit integer, the loop runs a constant number of times, making the solution `O(1)` in time complexity.
* **Result Construction:** Shifting the `result` *before* adding the bit or carefully managing the shift ensures bits end up in the correct reversed positions. In this approach, we shift `result` left to push existing bits "up" to make room for the new LSB at the bottom.

---
## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/reverse-bits/description/) for original content and copyright.**