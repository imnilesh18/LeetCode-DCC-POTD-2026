# 761. Special Binary String

<div align="center">
  <a href="https://leetcode.com/problems/special-binary-string/">
    <img src="https://img.shields.io/badge/LeetCode-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode" />
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Hard-red?style=for-the-badge" alt="Hard" />
  <img src="https://img.shields.io/badge/Tags-String%20%7C%20Recursion%20%7C%20Divide%20and%20Conquer-blue?style=for-the-badge" alt="Tags" />
</div>

## ğŸ“œ Problem Statement

**Special binary strings** are binary strings with the following two properties:
1. The number of `0`'s is equal to the number of `1`'s.
2. Every prefix of the binary string has at least as many `1`'s as `0`'s.

You are given a **special binary** string `s`.

A move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.

Return *the lexicographically largest resulting string possible after applying the mentioned operations on the string.*

---

## ğŸ¯ Constraints

- `1 <= s.length <= 50`
- `s[i]` is either `'0'` or `'1'`.
- `s` is a special binary string.

---

## ğŸ’¡ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `s = "11011000"` | `"11100100"` | The strings `"10"` [occurring at `s[1]`] and `"1100"` [at `s[3]`] are swapped. This is the lexicographically largest string possible after some number of swaps. |
| **2** | `s = "10"` | `"10"` | There are no two consecutive special substrings to swap. |

---

## ğŸ§  Approach

The problem perfectly maps to the concept of **Balanced Parentheses**. If we replace `'1'` with an opening parenthesis `(` and `'0'` with a closing parenthesis `)`, a "Special Binary String" effectively becomes a "Valid Balanced Parentheses String".

**Key Observations:**
1. **Boundaries of a Special String:** Every valid special string will always start with `'1'` and end with `'0'`. If we treat `'1'` as `+1` and `'0'` as `-1`, whenever our running sum becomes `0`, it indicates that we have encountered a complete special substring.
2. **Recursive Nature:** A larger special string can contain multiple consecutive special substrings, and those substrings themselves can contain inner special substrings. Thus, the problem is highly recursive. To maximize the lexicographical value of the outer string, we must also maximize the lexicographical value of the inner substrings.
3. **Sorting to Maximize:** The operation allows us to swap any adjacent special substrings. Essentially, this means we can arbitrarily reorder any consecutive special substrings at the same depth level. To form the lexicographically largest string, we simply need to collect all special substrings at a given depth, sort them in **descending order**, and concatenate them.

**Step-by-Step Logic:**
1. Scan the string from left to right. Maintain a `sum` counter (`+1` for `'1'`, `-1` for `'0'`).
2. When `sum == 0`, we have isolated a valid special substring.
3. Strip the outer `'1'` and `'0'` from this substring to get the `inner` string.
4. Call the recursion on the `inner` string to fetch its lexicographically optimal version.
5. Re-wrap the optimized inner string with `'1'` and `'0'` and store it in a list.
6. Once the entire string is parsed into adjacent special substrings, sort the list in descending order.
7. Concatenate all elements of the sorted list and return.

---

## ğŸ’» Solution Code

```cpp
// Intuition: The problem simulates balanced parentheses where '1' is '(' and '0' is ')'. Since we can swap any consecutive balanced substrings, we can essentially sort them to make the string lexicographically largest. We apply this recursively to inner substrings.
// Approach: 
// 1. Traverse the string while keeping a running balance (+1 for '1', -1 for '0').
// 2. Whenever the balance becomes 0, we've found a complete special substring.
// 3. Extract the inner content of this substring (excluding the first '1' and last '0').
// 4. Recursively process this inner content.
// 5. Wrap the optimized inner string back with '1' and '0', and store it in an array.
// 6. Sort the array of processed substrings in descending order to maximize the result.
// 7. Concatenate and return.
// Time Complexity: ~O(n^2). Scanning the string takes O(N). Removing the outer '1' and '0' gives an inner string of length N-2. The recurrence roughly processes lengths like N + (N-2) + (N-4) ..., forming an arithmetic progression that sums up to O(N^2). Sorting adds a minor O(K log K) factor per level, but O(N^2) remains the dominant term.
// Space Complexity: O(n). Auxiliary space is used for the recursive call stack (which goes up to O(N/2) depth in the worst case) and for storing the string slices in vectors at each recursive step.

class Solution {
public:
    string makeLargestSpecial(string s) {
        vector<string> specials; // Stores all optimized adjacent special substrings
        
        int start = 0; // Pointer to mark the start of current substring
        int sum = 0;   // Balance counter (+1 for '1', -1 for '0')
        
        for(int i = 0; i < s.length(); i++) {
            // Treat '1' as opening and '0' as closing bracket
            sum += s[i] == '1' ? 1 : -1;
            
            // When balanced, we found a valid special substring
            if(sum == 0) {
                // Extract inner string (excluding the first '1' and last '0')
                string inner = s.substr(start+1, i-start-1);
                
                // Recursively solve inner part, wrap with '1' and '0'
                specials.push_back("1" + makeLargestSpecial(inner) + "0");
                
                // Update start pointer for the next adjacent special substring
                start = i+1;
            }
        }

        // Sort in descending order to maximize the lexicographical value
        sort(begin(specials), end(specials), greater<string>());
        
        string result;
        // Concatenate all optimal substrings
        for(string &str : specials) {
            result += str;
        }
        
        return result;    
    }
};

/*
*
* Dry Run
* Input: s = "11011000"
* * 1. Main Call on "11011000":
* - Scanning... sum becomes 0 at the last index. 
* - Found complete special string: "11011000"
* - Inner string to process recursively: "101100" (indices 1 to 6)
* * 2. Recursive Call 1 on "101100":
* - Scanning... sum becomes 0 at index 1.
* - Found special string: "10". Inner is empty "".
* - Recursion on "" returns "". Wrapped: "1" + "" + "0" = "10".
* - Pushed to list: ["10"].
* - Scanning continues... sum becomes 0 at index 5.
* - Found special string: "1100". Inner is "10".
* * 3. Recursive Call 2 on "10":
* - Returns "10" (base case logic).
* - Wrapped: "1" + "10" + "0" = "1100".
* - Pushed to list at Level 2: ["10", "1100"].
* * 4. Back to Recursive Call 1:
* - List holds: ["10", "1100"].
* - Sort descending: ["1100", "10"].
* - Concatenated string: "110010".
* - Return "110010" to main call.
* * 5. Back to Main Call:
* - Wrap the returned optimized inner string: "1" + "110010" + "0".
* - Result: "11100100".
* * Final Output: "11100100"
*
*/

```

---

## ğŸ“ Notes

* Notice the similarity between finding Special Binary Substrings and parsing generic balanced Parentheses. They share the identical mathematical properties representing deep nesting and hierarchical structures.
* Sorting the substrings allows us to effortlessly bypass manual permutation generation; since `1` acts as a heavy/large prefix, greedily bringing substrings with more `1`s to the front inherently forces the string to its lexicographical maximum.

## ğŸ” Key Insights

* The constraint strictly bounds length up to `50`. This generous limit makes the recursive tree relatively small, permitting sorting operations and string concatenations dynamically without facing Time Limit Exceeded (TLE) errors.
* Continuous swapping of adjacent elements effectively grants us the liberty to perform a full **Sort** on the top-level items of the same hierarchy. This simplifies the mathematical objective of swapping completely into standard string sorting.

## ğŸš€ Further Exploration

* Try extending this concept to valid parentheses permutations (e.g., LeetCode #20 Valid Parentheses, LeetCode #22 Generate Parentheses).
* Explore problems where converting brackets to `+1` / `-1` helps in parsing logical expression strings.

## ğŸ“š References

* [LeetCode 761. Special Binary String](https://leetcode.com/problems/special-binary-string/)

## ğŸ·ï¸ Tags

* `String`
* `Recursion`
* `Divide and Conquer`

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/special-binary-string/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://www.google.com/search?q=https://github.com/imnilesh18)