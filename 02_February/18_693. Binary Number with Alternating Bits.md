# 693. Binary Number with Alternating Bits
---

| Attribute | Description |
| :--- | :--- |
| **Problem Link** | [LeetCode 693. Binary Number with Alternating Bits](https://leetcode.com/problems/binary-number-with-alternating-bits/description/) |
| **Problem Name** | 693. Binary Number with Alternating Bits |
| **Difficulty** | Easy |
| **Tags** | Bit Manipulation |
| **Badges** | ![Level](https://img.shields.io/badge/Level-Easy-green.svg) ![Solved](https://img.shields.io/badge/Status-Solved-blue.svg) |
| **Author** | [imnilesh18](https://github.com/imnilesh18) |

---

## ğŸ“ Problem Statement

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

In simple terms, the binary representation must look like `1010...` or `0101...` without any consecutive `00` or `11`.

## ğŸ” Constraints

- `1 <= n <= 2^31 - 1`

## ğŸ’¡ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **Example 1** | `n = 5` | `true` | The binary representation of 5 is: `101`. Adjacent bits differ. |
| **Example 2** | `n = 7` | `false` | The binary representation of 7 is: `111`. Adjacent bits are the same. |
| **Example 3** | `n = 11` | `false` | The binary representation of 11 is: `1011`. The last two bits are `11`. |

---

## ğŸ“– Explanation

To solve this problem, we need to verify that no two adjacent bits in the binary representation of `n` are identical. We can explore three approaches:

### Approach 1: Using Bitset
We can convert the integer into a binary string or use a container like C++ `bitset` to access individual bits by index. We iterate through the bits up to the most significant bit and check if `bit[i] == bit[i+1]`.

### Approach 2: Iterative Modulo & Division
This approach mimics the manual decimal-to-binary conversion. We extract the last bit using `n % 2`. We then right-shift the number (`n / 2`) to process the next bit. We compare the current last bit with the previous one. If they are ever the same, we return `false`.

### Approach 3: Constant Time Bitwise Operation
This is the most optimized approach.
1. If `n` has alternating bits (e.g., `1010`), then shifting it right by 1 (`0101`) and performing an **XOR** operation (`^`) will result in a number consisting entirely of 1s (e.g., `1111`).
2. To verify if a number `X` consists of all 1s, we can check if `X & (X + 1) == 0`.
   * For example, if `X = 7` (`111`), `X + 1 = 8` (`1000`). `0111 & 1000 = 0000`.

---

## ğŸ’» Solution Code

### Approach 1: Using Bitset (C++)

```cpp
// Intuition: Use a container to access bits by index and compare neighbors.
// Approach: Convert number to bitset, find bit length using log2, then loop to check adjacent equality.
// Time Complexity: O(log n) - proportional to number of bits.
// Space Complexity: O(1) - bitset size is constant (32).

class Solution {
public:
    bool hasAlternatingBits(int n) {
        bitset<32> b(n); // Store binary form
        int bits = log2(n); // Find position of MSB
        
        // Iterate up to the effective number of bits
        for(int i = 0; i < bits; i++) {
            // If current bit equals next bit, return false
            if(b[i] == b[i+1]) return false;
        }
        return true;
    }
};

/*
*
* Dry Run
* Input: n = 5 (101)
* b = ...000101
* bits = log2(5) = 2
* i=0: b[0] is 1, b[1] is 0. Differs. Continue.
* i=1: b[1] is 0, b[2] is 1. Differs. Continue.
* Loop ends. Return true.
*
*/

```

### Approach 2: Iterative Modulo & Division (C++)

```cpp
// Intuition: Check the last bit, shift right, and compare with the previous last bit.
// Approach: Store n%2, divide n by 2, then loop comparing currBit with new n%2.
// Time Complexity: O(log n) - iterating through bits.
// Space Complexity: O(1) - minimal extra variables.

class Solution {
public:
    bool hasAlternatingBits(int n) {
        int currBit = n % 2; // Get LSB
        n /= 2; // Shift right

        while (n > 0) {
            // Check if current LSB matches previous LSB
            if (currBit == n % 2) 
                return false;
            
            currBit = n % 2; // Update previous bit

            n /= 2; // Move to next bit
        }
        
        return true;
    }
};

/*
*
* Dry Run
* Input: n = 7 (111)
* Initial: currBit = 1, n = 3 (11)
* Loop 1: currBit(1) == 3%2(1). Match found.
* Return false.
*
*/

```

### Approach 3: Constant Time Bitwise Operation (C++)

```cpp
// Intuition: If bits alternate, n ^ (n>>1) will create a sequence of all 1s (like 111...1).
// Approach: XOR n with n>>1, then verify the result is all 1s using (x & x+1) check.
// Time Complexity: O(1) - fixed number of bitwise operations.
// Space Complexity: O(1) - no extra structure used.

class Solution {
public:
    bool hasAlternatingBits(int n) {
        // n = 101, n>>1 = 010, XOR = 111
        unsigned int result = n ^ (n >> 1);

        // Verify result is all 1s (form 2^k - 1)
        // Use unsigned int to prevent overflow on +1
        return (result & (result + 1)) == 0;
    }
};

/*
*
* Dry Run
* Input: n = 10 (1010)
* n >> 1 = 5 (0101)
* result = 1010 ^ 0101 = 1111 (15)
* result + 1 = 16 (10000)
* Check: 01111 & 10000 = 00000.
* Result is 0, so return true.
*
*/

```

---

## ğŸ”‘ Key Insights

* **Alternating Pattern**: The core property implies that shifting the number by 1 creates the perfect complement at every position except the edges.
* **XOR Logic**: `0 ^ 1 = 1`. If every adjacent pair differs, `n ^ (n >> 1)` guarantees a stream of `1`s.
* **Power of 2 Check**: A number consisting of all ones (`11...1`) is one less than a power of 2. `x & (x + 1) == 0` is the standard check for this property (checking if `x + 1` is a power of 2).

## ğŸ› ï¸ Further Exploration

* [Bit Manipulation Tricks]()
* [Understand Unsigned Integer Overflow]()

---

## ğŸ“„ License

This repository is released under the [MIT License]().

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement]() for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18]()