# 3640. Trionic Array II

<p align="center">
  <a href="https://leetcode.com/problems/trionic-array-ii/">
    <img src="https://img.shields.io/badge/LeetCode-3640-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 3640">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github" alt="Author">
  </a>
</p>

## üìù Problem Statement

**Difficulty:** <span style="color:red">**Hard**</span>  
**Tags:** `Array`, `Dynamic Programming`, `Recursion`, `Memoization`

You are given an integer array `nums` of length `n`.

A **trionic subarray** is a contiguous subarray `nums[l...r]` (with `0 <= l < r < n`) for which there exist indices `l < p < q < r` such that:
1. `nums[l...p]` is **strictly increasing**,
2. `nums[p...q]` is **strictly decreasing**,
3. `nums[q...r]` is **strictly increasing**.

Return the *maximum sum* of any trionic subarray in `nums`.

It is guaranteed that at least one trionic subarray exists.

---

## üîê Constraints

- `4 <= n = nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- It is guaranteed that at least one trionic subarray exists.

---

## üîç Examples

### Example 1
| Input | Output | Explanation |
| :--- | :---: | :--- |
| `nums = [0,-2,-1,-3,0,2,-1]` | `-4` | **Pick l=1, p=2, q=3, r=5:**<br>- `nums[1...2] = [-2, -1]` (Inc)<br>- `nums[2...3] = [-1, -3]` (Dec)<br>- `nums[3...5] = [-3, 0, 2]` (Inc)<br>**Sum** = -2 + (-1) + (-3) + 0 + 2 = **-4**. |

### Example 2
| Input | Output | Explanation |
| :--- | :---: | :--- |
| `nums = [1,4,2,7]` | `14` | **Pick l=0, p=1, q=2, r=3:**<br>- `nums[0...1] = [1, 4]` (Inc)<br>- `nums[1...2] = [4, 2]` (Dec)<br>- `nums[2...3] = [2, 7]` (Inc)<br>**Sum** = 1 + 4 + 2 + 7 = **14**. |

---

## üí° Approach

The problem asks for the maximum sum of a "Trionic" subarray (Inc -> Dec -> Inc). This structure suggests a sequence of states or trends. We can model this using **Dynamic Programming** or **Recursion with Memoization**.

There are 4 distinct states (trends) we can be in while traversing the array:
1.  **Trend 0 (Not Started):** We haven't picked any element yet. We can either **skip** the current element or **start** the first increasing phase if `nums[i+1] > nums[i]`.
2.  **Trend 1 (First Increasing):** We are in the first increasing leg `l...p`. If `nums[i+1] > nums[i]`, we can continue this trend. If `nums[i+1] < nums[i]`, we must transition to the decreasing phase (Trend 2).
3.  **Trend 2 (Decreasing):** We are in the decreasing leg `p...q`. If `nums[i+1] < nums[i]`, we can continue this trend. If `nums[i+1] > nums[i]`, we must transition to the second increasing phase (Trend 3).
4.  **Trend 3 (Second Increasing):** We are in the final increasing leg `q...r`. If `nums[i+1] > nums[i]`, we can continue increasing. Importantly, at any point in Trend 3, we have the option to **end** the subarray and take the current accumulated sum as a candidate answer.

We use a recursive function `solve(index, trend)` which returns the maximum sum possible from that state. To handle overlapping subproblems (e.g., reaching the same index with the same trend multiple times), we store the results in a `memo` table. Since we want the maximum sum and values can be negative, we initialize our base comparisons with a very small number (like `LLONG_MIN/2`) to avoid overflow issues during addition.

---

## üíª Solution Code

```cpp
// Intuition: The problem requires finding a specific pattern (Inc-Dec-Inc) with maximum sum. We can model the progression through these phases as states in a state machine and find the max weight path using recursion.
// Approach: Use Recursion with Memoization. Define 4 trends: 0 (Start), 1 (Inc), 2 (Dec), 3 (Inc). Transition between trends based on comparison with the next element. At Trend 0, we can skip or start. At Trend 3, we can end or continue.
// Time Complexity: O(N) - There are N * 4 states, and each state takes O(1) time to compute.
// Space Complexity: O(N) - For the recursion stack and the memoization table of size N * 4.

class Solution {
public:
    typedef long long ll;
    int n;
    vector<vector<ll>> memo;

    ll solve(int i, int trend, vector<int>& nums) {
        // Base case: Reached end of array
        if(i == n) {
            // Only valid if we completed the full pattern (Trend 3)
            if(trend == 3) {
                return 0; // Valid end, return 0 to stop sum
            } else {
                return LLONG_MIN/2; // Invalid path, return small value
            }
        }

        // Return memoized result if available
        if(memo[i][trend] != LLONG_MIN) {
            return memo[i][trend];
        }

        ll take = LLONG_MIN/2;
        ll skip = LLONG_MIN/2;

        // Trend 0: We haven't started building the subarray yet
        // Option 1: Skip current element and try starting from next
        if(trend == 0) {
            skip = solve(i+1, 0, nums);
        }

        // Trend 3: We are in the final increasing phase
        // Option: We can end the subarray right here at nums[i]
        if(trend == 3) {
            take = nums[i]; // Take current and finish
        }

        // Check if next element exists to make transitions
        if(i+1 < n) {
            int curr = nums[i];
            int next = nums[i+1];

            // Transitions based on current trend and next value
            if(trend == 0 && next > curr) {
                // Start Trend 1 (First Increasing)
                take = max(take, curr + solve(i+1, 1, nums));
            } else if(trend == 1) {
                // In Trend 1 (Increasing)
                if(next > curr) {
                    // Continue increasing
                    take = max(take, curr + solve(i+1, 1, nums));
                } else if(next < curr) {
                    // Switch to Trend 2 (Decreasing)
                    take = max(take, curr + solve(i+1, 2, nums));
                }
            } else if(trend == 2) {
                // In Trend 2 (Decreasing)
                if(next < curr) {
                    // Continue decreasing
                    take = max(take, curr + solve(i+1, 2, nums));
                } else if(next > curr) {
                    // Switch to Trend 3 (Second Increasing)
                    take = max(take, curr + solve(i+1, 3, nums));
                }
            } else if(trend == 3 && next > curr) {
                // In Trend 3 (Second Increasing)
                // Continue increasing. Note: 'take' already has the "finish here" value
                take = max(take, curr + solve(i+1, 3, nums));
            }
        }
        
        // Store and return max of taking or skipping (if applicable)
        return memo[i][trend] = max(take, skip);
    }

    ll maxSumTrionic(vector<int>& nums) {
        n = nums.size();

        // Initialize memo table with a sentinel value
        memo.assign(n+1, vector<ll>(4, LLONG_MIN));

        return solve(0, 0, nums); // Start from index 0, trend 0
    }
};

/*
*
* Dry Run
* Example: nums = [1, 4, 2, 7]
* * solve(0, 0) -> Trend 0, Val 1
* - Skip: solve(1, 0)
* - Take (Start Trend 1, 4 > 1): 1 + solve(1, 1)
* * solve(1, 1) -> Trend 1, Val 4
* - Next is 2 (2 < 4). Must switch to Trend 2.
* - Returns: 4 + solve(2, 2)
* * solve(2, 2) -> Trend 2, Val 2
* - Next is 7 (7 > 2). Must switch to Trend 3.
* - Returns: 2 + solve(3, 3)
* * solve(3, 3) -> Trend 3, Val 7
* - Option A (Finish): Returns 7
* - Option B (Continue): i+1 is out of bounds.
* - Max is 7.
*
* Result Chain: 1 + 4 + 2 + 7 = 14.
* Correct Answer: 14.
*
*/

```

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/trionic-array-ii/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
