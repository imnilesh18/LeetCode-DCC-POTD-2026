# 3637. Trionic Array I

<p align="center">
  <a href="https://leetcode.com/problems/trionic-array-i/">
    <img src="https://img.shields.io/badge/LeetCode-3637-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode Problem" />
  </a>
  <br />
  <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty" />
  <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="Language" />
  <img src="https://img.shields.io/badge/Topic-Array-blueviolet?style=for-the-badge" alt="Topic" />
  <img src="https://img.shields.io/badge/Pattern-Simulation-orange?style=for-the-badge" alt="Pattern" />
</p>

## üìù Problem Statement

You are given an integer array `nums` of length `n`.

An array is **trionic** if there exist indices `0 < p < q < n ‚àí 1` such that:
1. `nums[0...p]` is **strictly increasing**,
2. `nums[p...q]` is **strictly decreasing**,
3. `nums[q...n ‚àí 1]` is **strictly increasing**.

Return `true` if `nums` is trionic, otherwise return `false`.

---

## ‚õì Constraints

- `3 <= n <= 100`
- `-1000 <= nums[i] <= 1000`

---

## üîç Examples

### Example 1
| Input | Output | Explanation |
| :--- | :---: | :--- |
| `nums = [1,3,5,4,2,6]` | `true` | Pick `p = 2`, `q = 4`. <br> `[1, 3, 5]` is increasing. <br> `[5, 4, 2]` is decreasing. <br> `[2, 6]` is increasing. |

### Example 2
| Input | Output | Explanation |
| :--- | :---: | :--- |
| `nums = [2,1,3]` | `false` | There is no way to pick `p` and `q` to form the required three segments. |

---

## üí° Approach

The problem asks us to verify if the array follows a specific "mountain valley" pattern: **Up -> Down -> Up**. Since we need to find if *any* such partition exists, and the conditions are strictly sequential, we can simulate the traversal of the array to find these segments greedily.

**Steps:**
1.  **First Increasing Segment:** Start from index `0`. Traverse as long as the next element is strictly greater. Let's say we stop at index `p`.
    * *Check:* If `p` hasn't moved (is `0`) or has reached the end (`n-1`), we fail because we need space for the subsequent decreasing and increasing parts.
2.  **Decreasing Segment:** Continue from `p`. Traverse as long as the next element is strictly smaller. Let's say we stop at index `q`.
    * *Check:* If `q` has reached the very end (`n-1`), we fail because we still need a final increasing segment.
3.  **Second Increasing Segment:** Continue from `q`. Traverse as long as the next element is strictly greater.
4.  **Final Validation:** If our pointer successfully reached the last index (`n-1`) after completing all three phases, the array is Trionic.

---

## üíª Solution Code

```cpp
// Intuition: The problem requires checking for a specific sequence pattern: up, down, up. We can verify this by simply simulating the traversal through the array segments sequentially.
// Approach: 
// 1. Traverse strictly increasing elements. Ensure we moved from start but didn't reach the end.
// 2. Traverse strictly decreasing elements. Ensure we didn't reach the end yet.
// 3. Traverse remaining strictly increasing elements.
// 4. Return true if we successfully traversed the entire array (index reached n-1).
// Time Complexity: O(n) as we traverse the array at most once.
// Space Complexity: O(1) as no extra space is used.

class Solution {
public:
    bool isTrionic(vector<int>& nums) {
        int n = nums.size();

        int i = 0;

        // Increasing
        // Traverse the first strictly increasing segment
        while(i + 1 < n && nums[i] < nums[i + 1]) {
            i++;
        }

        // If we didn't move (i==0) or reached the end (i==n-1), valid partitions p and q cannot exist
        if(i == 0 || i == n - 1) {
            return false;
        }

        // Decreasing
        // Traverse the strictly decreasing segment
        while(i + 1 < n && nums[i] > nums[i + 1]) {
            i++;
        }

        // If we reached the end here, we can't form the final increasing segment
        if(i == n - 1) {
            return false;
        }

        // Increasing
        // Traverse the final strictly increasing segment
        while(i + 1 < n && nums[i] < nums[i + 1]) {
            i++;
        }

        // Check if we have successfully traversed the entire array
        return i == n - 1;
    }
};

/*
*
* Dry Run
* Input: nums = [1, 3, 5, 4, 2, 6]
* n = 6, i starts at 0
*
* 1. First Loop (Increasing):
* - i=0: nums[0] (1) < nums[1] (3) -> i becomes 1
* - i=1: nums[1] (3) < nums[2] (5) -> i becomes 2
* - i=2: nums[2] (5) !< nums[3] (4) -> Loop terminates
* - Check: i (2) is not 0 and not 5. Valid.
*
* 2. Second Loop (Decreasing):
* - i=2: nums[2] (5) > nums[3] (4) -> i becomes 3
* - i=3: nums[3] (4) > nums[4] (2) -> i becomes 4
* - i=4: nums[4] (2) !> nums[5] (6) -> Loop terminates
* - Check: i (4) is not 5. Valid.
*
* 3. Third Loop (Increasing):
* - i=4: nums[4] (2) < nums[5] (6) -> i becomes 5
* - i=5: Reached end of array -> Loop terminates
*
* 4. Final Check:
* - i == n - 1 (5 == 5) -> Returns true
*
*/

```

---

## üìì Notes & Key Insights

* **Linear Scan:** The solution works in a single pass (), making it very efficient.
* **Edge Case Handling:** Critical checks are checking if `i` moved at start (`i == 0`) or if `i` exhausted the array too early (`i == n - 1`) before forming all segments.
* **Three Segments:** The problem strictly demands **three** segments. A simple mountain array (Up -> Down) would return `false` because it lacks the final Up segment.

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/trionic-array-i/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
