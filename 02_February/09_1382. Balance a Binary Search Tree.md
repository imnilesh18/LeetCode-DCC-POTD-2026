# 1382. Balance a Binary Search Tree

<p align="center">
  <a href="https://leetcode.com/problems/balance-a-binary-search-tree/submissions/">
    <img src="https://img.shields.io/badge/LeetCode-1382-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode Problem" />
  </a>
  <br />
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Medium Difficulty" />
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white" alt="C++" />
</p>

## üìù Problem Statement

Given the `root` of a binary search tree, return *a **balanced** binary search tree with the same node values*. If there is more than one answer, return **any of them**.

A binary search tree is **balanced** if the depth of the two subtrees of every node never differs by more than `1`.

---

### üì∑ Examples

**Example 1:**

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg" alt="Example 1 Image" width="500" />
</p>

```text
Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.

```

**Example 2:**

<p align="center">
<img src="https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg" alt="Example 2 Image" width="200" />
</p>

```text
Input: root = [2,1,3]
Output: [2,1,3]

```

---

### ‚ö†Ô∏è Constraints

* The number of nodes in the tree is in the range `[1, 10^4]`.
* `1 <= Node.val <= 10^5`

---

## üí° Approach & Explanation

### Key Insights

1. **BST Property**: An **Inorder Traversal** of a Binary Search Tree (BST) always yields node values in a **sorted ascending order**.
2. **Balancing Strategy**: To create a height-balanced BST from a sorted sequence, we should pick the **middle element** as the root. This ensures that roughly half the nodes are in the left subtree and half are in the right subtree, minimizing height.
3. **Recursion**: This process is naturally recursive. Once the middle element is chosen as the root, the problem splits into two smaller sub-problems: building a balanced left subtree from the left half of the array and a balanced right subtree from the right half.

### Detailed Steps

1. **Inorder Traversal**:
* Perform an inorder traversal (Left -> Root -> Right) on the given unbalanced BST.
* Store the node values in a standard array or vector. This gives us the sorted version of the tree's data.


2. **Construct Balanced BST**:
* Use a recursive helper function that takes the `start` and `end` indices of the sorted vector.
* **Base Case**: If `start > end`, return `NULL` (no elements to form a tree).
* **Recursive Step**:
* Calculate `mid = start + (end - start) / 2`.
* Create a new `TreeNode` using the value at `vector[mid]`.
* Recursively set `root->left` using the subarray `[start, mid - 1]`.
* Recursively set `root->right` using the subarray `[mid + 1, end]`.


* Return the newly created `root`.



---

## üíª Solution Code

```cpp
// Intuition: Inorder traversal of a BST gives sorted elements. We can construct a balanced BST from a sorted array by recursively picking the middle element as the root.
// Approach: 1. Traverse tree inorder to get sorted array. 2. Recursively build tree from array using midpoints.
// Time Complexity: O(N) - We visit every node once for inorder traversal and once for construction.
// Space Complexity: O(N) - To store the sorted elements in a vector.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // Helper function to perform Inorder Traversal and store values
    void inOrder(TreeNode* root, vector<int>& vec) {
        if(!root)
            return;
        
        inOrder(root->left, vec);       // Visit Left
        vec.push_back(root->val);       // Store Root
        inOrder(root->right, vec);      // Visit Right
    }

    // Helper function to construct a balanced BST from sorted vector
    TreeNode* construct(int l, int r, vector<int>& vec) {
        // Base case: no elements left to construct subtree
        if(l > r)
            return NULL;
        
        // Pick middle element to ensure balance
        int mid = l + (r-l)/2;
        TreeNode* root = new TreeNode(vec[mid]);

        // Recursively build left and right subtrees
        root->left  = construct(l, mid-1, vec);
        root->right = construct(mid+1, r, vec);

        return root;
    }

    TreeNode* balanceBST(TreeNode* root) {
        vector<int> vec;
        inOrder(root, vec); // Phase 1: Flatten tree to sorted array
        
        int l = 0, r = vec.size()-1;
        return construct(l, r, vec); // Phase 2: Rebuild balanced tree
    }
};

/*
*
* Dry Run
* Input: root = [1, null, 2, null, 3] (Skewed Right)
* * 1. inOrder(root, vec):
* - Traverses 1 -> 2 -> 3
* - vec becomes [1, 2, 3]
*
* 2. construct(0, 2, vec):
* - l=0, r=2 -> mid = 1
* - root = new TreeNode(vec[1]) -> Node(2)
* * - Left Child: construct(0, 0, vec)
* - l=0, r=0 -> mid = 0
* - root = new TreeNode(vec[0]) -> Node(1)
* - Left: construct(0, -1) -> NULL
* - Right: construct(1, 0) -> NULL
* - Returns Node(1)
*
* - Right Child: construct(2, 2, vec)
* - l=2, r=2 -> mid = 2
* - root = new TreeNode(vec[2]) -> Node(3)
* - Left: construct(2, 1) -> NULL
* - Right: construct(3, 2) -> NULL
* - Returns Node(3)
*
* 3. Result Tree:
* 2
* / \
* 1   3
* (Balanced)
*/

```

---

## üìì Notes

* **Alternative In-Place Approach**: It is possible to balance a BST without using O(N) extra space for the vector by using the **DSW (Day-Stout-Warren) Algorithm**. This involves performing tree rotations to convert the tree into a linked list (backbone) and then balancing it. However, this is more complex and usually not required for standard interviews where O(N) space is acceptable.
* **Stability**: The approach used here creates a new tree structure. While it preserves the values, the original node pointers are effectively replaced (or new ones created depending on memory management), which is a valid strategy for this problem.

---

## üè∑Ô∏è Tags

`Binary Search Tree` `Depth-First Search` `Divide and Conquer` `Greedy` `Binary Tree`

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/balance-a-binary-search-tree/submissions/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
