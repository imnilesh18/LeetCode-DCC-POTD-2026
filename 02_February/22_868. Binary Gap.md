# 868. Binary Gap

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen" alt="Difficulty">
  <img src="https://img.shields.io/badge/Bit%20Manipulation-blue" alt="Tag">
  <img src="https://img.shields.io/badge/Math-blue" alt="Tag">
</p>

## ğŸ“œ Problem Statement
Given a positive integer `n`, find and return the longest distance between any two adjacent `1`'s in the binary representation of `n`. If there are no two adjacent `1`'s, return `0`.

Two `1`'s are adjacent if there are only `0`'s separating them (possibly no `0`'s). The distance between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `"1001"` have a distance of 3.

---

## ğŸ¯ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `n = 22` | `2` | 22 in binary is `"10110"`.<br>The first adjacent pair of 1's is `"10110"` with a distance of 2.<br>The second adjacent pair of 1's is `"10110"` with a distance of 1.<br>The answer is the largest of these two distances, which is 2. |
| **2** | `n = 8` | `0` | 8 in binary is `"1000"`.<br>There are no adjacent pairs of 1's in the binary representation of 8, so we return 0. |
| **3** | `n = 5` | `2` | 5 in binary is `"101"`. |

---

## ğŸ›‘ Constraints
- `1 <= n <= 10^9`

---

## ğŸ’¡ Approach

To solve this problem, we can use **Bit Manipulation**.
Since the maximum value of `n` is `10^9`, it requires at most 30 bits to be represented in binary (`2^30 â‰ˆ 10^9`).

We can iterate through each bit of `n`. Whenever we encounter a `1`, we compare its current position (`curr`) with the position of the previously seen `1` (`prev`) and calculate the distance between them. We keep track of the maximum distance found so far in a variable.

---

## ğŸ’» Solution Code

### 1ï¸âƒ£ Brute-force / While Loop Approach (O(log n) Time)

```cpp
// Intuition: We can shift the bits of n to the right one by one and check if the current rightmost bit is 1. If it is, we calculate the distance from the previously recorded position of 1.
// Approach:
// 1. Initialize `curr` to 0 and `prev` to -1 (indicating no 1 has been seen yet).
// 2. Run a loop as long as `n > 0`.
// 3. If the current bit is 1 (i.e., `n & 1`), update the maximum distance (`result`) if `prev` is not -1.
// 4. Update `prev` to `curr`.
// 5. Increment `curr` and right-shift `n` by 1 (`n >>= 1`).
// 6. Return the maximum distance.
// Time Complexity: O(log n), where n is the given number. We iterate through each bit of n, which is proportional to log n.
// Space Complexity: O(1), as we are only using a few integer variables.

class Solution {
public:
    int binaryGap(int n) {
        int curr = 0; // Current bit position
        int prev = -1; // Position of the previous 1

        int result = 0; // Maximum distance

        while(n > 0) {
            // If the current rightmost bit is 1
            if((n & 1) > 0) {
                // Update the maximum distance
                result = (prev != -1) ? max(result, curr - prev) : result;
                prev = curr; // Update the previous 1's position
            }

            curr++; // Increment current position
            n >>= 1; // Right shift n
        }
        return result;
    }
};

/*
*
* Dry Run
* n = 22 (Binary: 10110)
* curr = 0, prev = -1, result = 0
*
* Iteration 1: n=22 (10110), bit=0. curr=1, n=11 (1011)
* Iteration 2: n=11 (1011), bit=1. result=0, prev=1. curr=2, n=5 (101)
* Iteration 3: n=5 (101), bit=1. result=max(0, 2-1)=1, prev=2. curr=3, n=2 (10)
* Iteration 4: n=2 (10), bit=0. curr=4, n=1 (1)
* Iteration 5: n=1 (1), bit=1. result=max(1, 4-2)=2, prev=4. curr=5, n=0
*
* Loop ends. result = 2
*
*/
```

### 2ï¸âƒ£ Optimized Approach (32 Bits For Loop)

```cpp
// Intuition: Since an integer has a maximum of 32 bits, we can iterate exactly 32 times to check each bit, simplifying the logic without modifying the original number continuously.
// Approach: 
// 1. Initialize `prev` to -1 and `result` to 0.
// 2. Loop through each bit position (`curr`) from 0 to 31.
// 3. Check if the bit at the `curr` position is 1 using `((n >> curr) & 1)`.
// 4. If it is 1, calculate the distance from `prev` and update `result` with the maximum distance.
// 5. Update `prev` to the current position.
// 6. Return `result` after the loop.
// Time Complexity: O(1), since the loop runs exactly 32 times, taking constant time.
// Space Complexity: O(1), as no extra space is used.

class Solution {
public:
    int binaryGap(int n) {
        int prev = -1; // Position of the previous 1

        int result = 0; // Maximum distance

        // Loop for 32 bits
        for(int curr = 0; curr < 32; curr++) {
            // Check if the current bit is 1
            if(((n >> curr) & 1) > 0) {
                // Update maximum distance
                result = (prev != -1) ? max(result, curr - prev) : result;
                prev = curr; // Update prev
            }
        }

        return result;
    }
};

/*
*
* Dry Run
* n = 5 (Binary: 101)
* prev = -1, result = 0
*
* curr=0: (5>>0)&1 = 1. prev=-1. result=0, prev=0
* curr=1: (5>>1)&1 = 0.
* curr=2: (5>>2)&1 = 1. prev=0. result=max(0, 2-0)=2, prev=2
* curr=3 to 31: All bits are 0.
*
* Loop ends. result = 2
*
*/
```

---

## ğŸ“ Notes
- This problem is an excellent exercise for understanding **Bit Manipulation**.
- Using the bitwise AND `&` and right shift `>>` operators allows us to easily process numbers in their binary form.
- Due to the nature of 32-bit integers, the time complexity is extremely minimal (bounded to O(1) or O(log n)), making the approach highly efficient.

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/binary-gap/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)