# 3013. Divide an Array Into Subarrays With Minimum Cost II

<p align="center">
  <a href="https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/">
    <img src="https://img.shields.io/badge/LeetCode-3013-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 3013"/>
  </a>
  <span style="margin: 0 10px;"></span>
  <img src="https://img.shields.io/badge/Difficulty-Hard-red?style=for-the-badge&logoColor=white" alt="Hard"/>
  <span style="margin: 0 10px;"></span>
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white" alt="C++"/>
</p>

## üìù Problem Statement

You are given a **0-indexed** array of integers `nums` of length `n`, and two **positive** integers `k` and `dist`.

The **cost** of an array is the value of its **first** element. For example, the cost of `[1,2,3]` is `1` while the cost of `[3,4,1]` is `3`.

You need to divide `nums` into `k` **disjoint contiguous** subarrays, such that the difference between the starting index of the **second** subarray and the starting index of the **kth** subarray should be **less than or equal to** `dist`. In other words, if you divide `nums` into the subarrays `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]`, then `ik-1 - i1 <= dist`.

Return *the **minimum** possible sum of the cost of these subarrays*.

---

## üîí Constraints

- `3 <= n <= 10^5`
- `1 <= nums[i] <= 10^9`
- `3 <= k <= n`
- `k - 2 <= dist <= n - 2`

---

## üßê Examples

<details>
<summary><b>Example 1</b></summary>

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [1,3,2,6,4,2]`, `k = 3`, `dist = 3` | `5` | The best possible way to divide nums into 3 subarrays is: `[1,3]`, `[2,6,4]`, and `[2]`.<br>Start indices: `0`, `2`, `5`.<br>`ik-1 - i1` is `5 - 2 = 3` which is equal to `dist`.<br>Total cost: `1 + 2 + 2 = 5`. |

</details>

<details>
<summary><b>Example 2</b></summary>

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [10,1,2,2,2,1]`, `k = 4`, `dist = 3` | `15` | The best possible way to divide nums into 4 subarrays is: `[10]`, `[1]`, `[2]`, and `[2,2,1]`.<br>Start indices: `0`, `1`, `2`, `3`.<br>`ik-1 - i1` is `3 - 1 = 2` which is less than `dist`.<br>Total cost: `10 + 1 + 2 + 2 = 15`. |

</details>

<details>
<summary><b>Example 3</b></summary>

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [10,8,18,9]`, `k = 3`, `dist = 1` | `36` | The best possible way to divide nums into 3 subarrays is: `[10]`, `[8]`, and `[18,9]`.<br>Start indices: `0`, `1`, `2`.<br>`ik-1 - i1` is `2 - 1 = 1` which is equal to `dist`.<br>Total cost: `10 + 8 + 18 = 36`. |

</details>

---

## üí° Key Insights & Approach

### 1. Intuition
The problem asks to minimize the sum of the first elements of `k` subarrays.
- The first subarray **always** starts at index `0`, so `nums[0]` is a fixed part of the cost.
- We need to select `k-1` other starting indices (`i1, i2, ..., ik-1`) for the remaining subarrays.
- The constraint `ik-1 - i1 <= dist` implies that all chosen starting indices (from the 2nd to the `k`-th) must lie within a range (window) of size `dist + 1`.
- This transforms the problem into: **Find a window of size at most `dist + 1` starting from index 1 onwards, such that the sum of the `k-1` smallest elements within that window is minimized.**

### 2. Sliding Window with Two Sets
Since `dist` is fixed, we can use a **Sliding Window** approach. As the window moves one step to the right:
- One element enters the window.
- One element leaves the window (if the window size exceeds `dist + 1`).

To efficiently query the sum of the smallest `k-1` elements, we can maintain two **Ordered Sets** (or Priority Queues, though Sets allow easier deletion):
1.  **`kMinimum`**: Stores the smallest `k-1` elements of the current window. We also maintain a variable `sum` to track their total value.
2.  **`remaining`**: Stores all other valid elements currently in the window that are *not* among the smallest `k-1`.

### 3. Balancing the Sets
For every step of the sliding window:
- **Insertion**: Add the new element. First, try adding it to `kMinimum`. If `kMinimum` exceeds size `k-1`, move the largest element from `kMinimum` to `remaining`. Update `sum` accordingly.
- **Deletion**: Remove the element falling out of the window.
    - If it was in `kMinimum`: Remove it, subtract from `sum`, and promote the smallest element from `remaining` to `kMinimum` to fill the gap.
    - If it was in `remaining`: Just remove it.

This ensures we always have the minimal possible sum for the current window in `O(log K)` time per operation.

---

## üöÄ Code Solution

```cpp
// Intuition: The problem reduces to finding the minimum sum of (k-1) smallest elements within a sliding window of size roughly 'dist'. Since nums[0] is fixed, we just need to optimize the selection of the remaining k-1 starting positions.
// Approach: Use a Sliding Window combined with two Sets (kMinimum and remaining) to maintain the smallest (k-1) elements. As the window slides, we add new elements and remove old ones, rebalancing the sets to keep the sum updated efficiently.
// Time Complexity: O(n * log(k)) because for each element we perform insertion/deletion in sets which takes logarithmic time relative to the window size/k.
// Space Complexity: O(n) in the worst case to store elements in sets (specifically window size), though practically O(dist).

class Solution {
public:
    typedef long long ll;
    typedef pair<ll, ll> P;

    ll minimumCost(vector<int>& nums, int k, int dist) {
        int n = nums.size();

        // Stores the (k-1) smallest elements in the current window
        set<P> kMinimum; 
        // Stores the rest of the elements in the current window
        set<P> remaining;

        ll sum = 0; // Tracks the sum of elements in kMinimum

        int i = 1;
        
        // Initial phase: Fill the window until the constraint (i - dist < 1) is met.
        // Basically, preparing the first valid window starting from index 1.
        while(i - dist < 1) {
            kMinimum.insert({nums[i], i});
            sum += nums[i];
            
            // If we have more than required (k-1) elements, move the largest to 'remaining'
            if(kMinimum.size() > k-1) {
                P temp = *kMinimum.rbegin(); // Get largest in kMinimum
                sum -= temp.first;
                remaining.insert(temp);
                kMinimum.erase(temp);
            }
            i++;
        }

        ll result = LONG_MAX; // Stores the minimum sum found so far

        // Sliding Window phase
        while(i < n) {
            // 1. Insert new element (nums[i]) into the window
            kMinimum.insert({nums[i], i});
            sum += nums[i];

            // Rebalance: Ensure kMinimum only has (k-1) elements
            if(kMinimum.size() > k-1) {
                P temp = *kMinimum.rbegin();
                sum -= temp.first;
                remaining.insert(temp);
                kMinimum.erase(temp);
            }

            // Update result with the current best sum
            result = min(result, sum);

            // 2. Remove the old element that is sliding out of the window
            // The element at 'i - dist' is no longer valid for the next window logic start
            P remove = {nums[i-dist], i-dist};
            
            if(kMinimum.count(remove)) {
                // If it was in the k-smallest set, remove it and update sum
                kMinimum.erase(remove);
                sum -= remove.first;

                // We need to fill the gap in kMinimum from 'remaining' if possible
                if(!remaining.empty()) {
                    P temp = *remaining.begin(); // Smallest in remaining
                    kMinimum.insert(temp);
                    sum += temp.first;
                    remaining.erase(temp);
                }
            } else {
                // If it was in the remaining set, just remove it
                remaining.erase(remove);
            }

            i++;
        }

        // Add the fixed cost of the first element
        return nums[0] + result;
    }
};

/*
*
* Dry Run
* Input: nums = [1,3,2,6,4,2], k = 3, dist = 3
* Fixed Cost: nums[0] = 1. Need (k-1) = 2 smallest elements from window.
*
* Initialization (i=1 to 3):
* i=1 (val 3): kMin={(3,1)}, sum=3.
* i=2 (val 2): kMin={(2,2), (3,1)}, sum=5. (Size is 2, ok).
* i=3 (val 6): kMin={(2,2), (3,1), (6,3)}. Size > 2. Move (6,3) to rem. sum=5. rem={(6,3)}.
* Window prepared. result updated.
*
* Sliding Loop (i=4 to 5):
* i=4 (val 4):
* - Insert (4,4) to kMin. kMin={(2,2), (3,1), (4,4)}, sum=9.
* - Balance: Size > 2. Move (4,4) to rem. kMin={(2,2), (3,1)}, sum=5. rem={(4,4), (6,3)}.
* - Update Result: min(MAX, 5) = 5.
* - Remove old: remove index i-dist = 4-3 = 1 (val 3). Pair (3,1).
* - (3,1) is in kMin. Erase. sum=5-3=2.
* - Refill from rem: Smallest is (4,4). kMin={(2,2), (4,4)}, sum=2+4=6. rem={(6,3)}.
*
* i=5 (val 2):
* - Insert (2,5) to kMin. kMin={(2,2), (2,5), (4,4)}, sum=8.
* - Balance: Size > 2. Move (4,4) to rem. kMin={(2,2), (2,5)}, sum=4. rem={(4,4), (6,3)}.
* - Update Result: min(5, 4) = 4.
* - Remove old: remove index i-dist = 5-3 = 2 (val 2). Pair (2,2).
* - (2,2) is in kMin. Erase. sum=4-2=2.
* - Refill from rem: Smallest is (4,4). kMin={(2,5), (4,4)}, sum=2+4=6. rem={(6,3)}.
*
* End Loop.
* Final Result = nums[0] + result = 1 + 4 = 5.
*/

```

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/) for original content and copyright.**

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
