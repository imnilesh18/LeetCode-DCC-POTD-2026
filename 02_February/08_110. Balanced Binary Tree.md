# 110. Balanced Binary Tree

<div align="center">

[![Status](https://img.shields.io/badge/Status-Solved-success?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/balanced-binary-tree/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/balanced-binary-tree/)
[![Language](https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B)](https://github.com/imnilesh18)

</div>

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="Balanced Binary Tree Example" width="400">
</p>

## üîó Problem Link

[**LeetCode: 110. Balanced Binary Tree**](https://leetcode.com/problems/balanced-binary-tree/)

## üíª Problem Name

**Balanced Binary Tree**

## üè∑Ô∏è Tags

`Tree` `Depth-First Search` `Binary Tree` `Recursion`

## üìÑ Problem Statement

Given a binary tree, determine if it is **height-balanced**.

A **height-balanced** binary tree is defined as:
> A binary tree in which the depth of the two subtrees of every node never differs by more than one.

## üßê Constraints

- The number of nodes in the tree is in the range `[0, 5000]`.
- `-10^4 <= Node.val <= 10^4`

## üí° Examples

### Example 1

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="Example 1 Image" width="300">
</div>

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `root = [3,9,20,null,null,15,7]` | `true` | The left subtree of 3 has height 1, and the right subtree has height 2. The difference is 1, which is allowed. All subtrees are also balanced. |

### Example 2

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="Example 2 Image" width="300">
</div>

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `root = [1,2,2,3,3,null,null,4,4]` | `false` | The left subtree of 1 has height 3, while the right subtree has height 1. The difference is 2, which is > 1. |

### Example 3

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `root = []` | `true` | An empty tree is considered balanced. |

## üìù Explanation

A binary tree is balanced if, for every node in the tree, the absolute difference between the height of its left subtree and the height of its right subtree is at most 1. This condition must hold true recursively for every node.

The approach involves two main logical steps:
1.  **Calculate Height:** We need a way to determine the height of any given subtree. The height is the number of edges on the longest path from the node to a leaf.
2.  **Check Balance:** For the current node, we compare the heights of its left and right children. If the difference is greater than 1, the tree is unbalanced. If it is within the limit, we must recursively verify that both the left and right subtrees are also balanced.

This top-down approach ensures that we validate the balance condition for the root and then propagate the check down to all children.

## üíª Solution Code

```cpp
// Intuition: Check the balance condition at the current node by calculating heights, then recursively check left and right subtrees.
// Approach: Top-down recursion. For every node, calculate left/right height, check difference <= 1, and recurse for children.
// Time Complexity: O(N^2) in worst case (skewed tree) because height() is called for every node. O(N log N) for balanced tree.
// Space Complexity: O(N) in worst case due to recursion stack space (skewed tree).

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    // Helper function to calculate the height of a tree
    int height(TreeNode* root) {
        // Base case: height of empty tree is 0
        if(!root){
            return 0;
        }

        // Recursively find height of left and right subtrees
        int leftH = height(root->left);
        int rightH = height(root->right);

        // Current height is max of children + 1
        return max(leftH, rightH) + 1;
    }

    // Main function to check if the tree is balanced
    bool isBalanced(TreeNode* root) {
        // Base case: empty tree is balanced
        if(!root){
            return true;
        }
        
        // Calculate height of left and right subtrees
        int leftH = height(root->left);
        int rightH = height(root->right);

        // If difference > 1, it's unbalanced
        if(abs(leftH - rightH) > 1) {
            return false;
        }

        // Recursively check if left and right subtrees are also balanced
        return isBalanced(root->left) && isBalanced(root->right);
    }
};

/*
*
* Dry Run
* Input: root = [3,9,20,null,null,15,7]
*
* 1. Call isBalanced(3):
* - height(9): Returns 1 (leaf node)
* - height(20): 
* - height(15) -> 1, height(7) -> 1
* - max(1,1) + 1 -> Returns 2
* - abs(1 - 2) = 1. Condition (1 > 1) is False.
* - Recurse: isBalanced(9) && isBalanced(20)
*
* 2. Call isBalanced(9):
* - height(null), height(null) -> 0, 0
* - abs(0 - 0) = 0. Balanced.
* - Returns True.
*
* 3. Call isBalanced(20):
* - height(15) -> 1, height(7) -> 1
* - abs(1 - 1) = 0. Balanced.
* - Recurse: isBalanced(15) && isBalanced(7)
* - Both 15 and 7 are leaves, will return True.
* - Returns True.
*
* 4. Result: True && True -> Return True.
*
*/
```

## üîç Key Insights

- **Height Calculation:** The `height` function visits every node in the subtree, making it an `O(N)` operation for a specific call.
- **Top-Down Logic:** Since we call `height` (which is `O(N)`) inside `isBalanced` for every single node, the total work accumulates.
- **Worst Case Performance:** In a skewed tree (like a linked list), calculating height repeatedly for every node leads to `N + (N-1) + ... + 1` operations, resulting in **O(N^2)** time complexity.
- **Recursion Stack:** The space complexity is determined by the maximum depth of the recursion tree, which is **O(N)** for a skewed tree and **O(log N)** for a balanced tree.

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/balanced-binary-tree/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)