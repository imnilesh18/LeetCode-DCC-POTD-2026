# 1653. Minimum Deletions to Make String Balanced

---

- **Problem Link:** [https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/)
- **Difficulty:** Medium
- **Tags:** [String, Stack, Greedy, Dynamic Programming]

---

## üí° Problem Statement

You are given a string `s` consisting only of characters `'a'` and `'b'`.

You can delete any number of characters in `s` to make `s` **balanced**. `s` is **balanced** if there is no pair of indices `(i,j)` such that `i < j` and `s[i] = 'b'` and `s[j]= 'a'`.

Return *the **minimum** number of deletions needed to make `s` balanced*.

---

## üîí Constraints

- `1 <= s.length <= 10^5`
- `s[i]` is `'a'` or `'b'`.

---

## üìù Examples

| Example | Input | Output | Explanation |
| :-: | :-: | :-: | :-: |
| **1** | `s = "aababbab"` | `2` | Delete the characters at 0-indexed positions 2 and 6 ("aa**b**abb**a**b" -> "aaabbb"), or delete positions 3 and 6 ("aab**a**bb**a**b" -> "aabbbb"). |
| **2** | `s = "bbaaaaabb"` | `2` | The only solution is to delete the first two characters. |

---

## üß† Approach & Intuition

The core problem is to prevent the pattern "ba" from occurring (a 'b' followed by an 'a'). A balanced string looks like some number of 'a's followed by some number of 'b's (e.g., "aaabbb", "aaaa", "bbbb").

### Approach 1: Using Stack
The intuition here is similar to checking for valid parentheses. Whenever we encounter an `'a'`, if there is a `'b'` available before it (on the stack), this forms a forbidden "ba" pair. We can "delete" this pair by removing the 'b' (popping from stack) and incrementing our deletion count. This essentially greedily removes the conflicting 'b' to allow the 'a' to exist, or we can think of it as removing the 'a'. In the optimal substructure, removing one character of the conflicting pair resolves that specific local conflict.

### Approach 2, 3, & 4: Partitioning
We can iterate through every possible "split point" in the string. For a split point at index `i`, we imagine everything to the left should be 'a's and everything to the right should be 'b's.
- To make the left side valid, we must delete all 'b's found so far.
- To make the right side valid, we must delete all 'a's found afterwards.
- Total Cost at index `i` = (Count of 'b's in `s[0...i-1]`) + (Count of 'a's in `s[i...n-1]`).
- We minimize this cost over all `i`.

Optimizations involve precomputing these counts (Prefix/Suffix arrays) or maintaining them on the fly to achieve O(1) space.

---

## üíª Solution Code

### Approach 1: Using Stack

```cpp
// Intuition: Greedily remove 'b's that appear before 'a's. A stack helps track the most recent 'b's that constitute a potential conflict.
// Approach: Iterate through string. Push 'b' to stack. If 'a' is found and stack has 'b', pop 'b' (simulate deletion) and increment count. Else push 'a'.
// Time Complexity: O(n) where n is the length of the string (one pass).
// Space Complexity: O(n) for the stack in the worst case.

class Solution {
public:
    int minimumDeletions(string s) {
        int n      = s.length();
        int count = 0;

        stack<char> st;

        for(int i = 0; i < n; i++) {
            // Check for 'ba' pattern which is invalid
            if(!st.empty() && s[i] == 'a' && st.top() == 'b') { //'ba'
                st.pop();   // Remove the conflicting 'b'
                count++;    // Increment deletion count
            } else {
                st.push(s[i]); // No conflict, push current char
            }
        }

        return count;
    }
};

/*
*
* Dry Run
* Input: s = "aababbab"
* i=0, s[0]='a': stack=['a']
* i=1, s[1]='a': stack=['a', 'a']
* i=2, s[2]='b': stack=['a', 'a', 'b']
* i=3, s[3]='a': Top is 'b', pair "ba" found. Pop 'b'. stack=['a', 'a'], count=1
* i=4, s[4]='b': stack=['a', 'a', 'b']
* i=5, s[5]='b': stack=['a', 'a', 'b', 'b']
* i=6, s[6]='a': Top is 'b', pair "ba" found. Pop 'b'. stack=['a', 'a', 'b'], count=2
* i=7, s[7]='b': stack=['a', 'a', 'b', 'b']
* Result: 2
*
*/

```

### Approach 2: 3 Pass (Prefix + Suffix Arrays)

```cpp
// Intuition: For every position, calculate cost to make left side all 'a's (delete 'b's) and right side all 'b's (delete 'a's).
// Approach: Precompute 'b' count from left and 'a' count from right. Iterate to find min sum of deletions.
// Time Complexity: O(3*n) -> O(n) due to three passes.
// Space Complexity: O(2*n) -> O(n) for two auxiliary arrays.

class Solution {
public:
    int minimumDeletions(string s) {
        int n      = s.length();
        
        vector<int> left_b(n, 0);
        vector<int> right_a(n, 0);

        int countb = 0;
        // Pass 1: Count 'b's to the left of current index
        for(int i = 0; i < n; i++) {
            left_b[i] = countb;
            if(s[i] == 'b')
                countb++;
        }

        int counta = 0;
        // Pass 2: Count 'a's to the right of current index
        for(int i = n-1; i >= 0; i--) {
            right_a[i] = counta;
            if(s[i] == 'a')
                counta++;
        }

        int count = INT_MAX;
        // Pass 3: Calculate minimum deletions required at each split point
        for(int i = 0; i < n; i++) {
            count = min(count, left_b[i] + right_a[i]);
        }

        return count;
    }
};

/*
*
* Dry Run
* Input: s = "bbaaa"
* n = 5
* Pass 1 (left_b): [0, 1, 2, 2, 2] (Number of 'b's before index i)
* Pass 2 (right_a): [3, 2, 1, 0, 0] (Number of 'a's after index i)
* Pass 3 (Sum):
* i=0: 0 + 3 = 3
* i=1: 1 + 2 = 3
* i=2: 2 + 1 = 3
* i=3: 2 + 0 = 2  <- Min
* i=4: 2 + 0 = 2
* Result: 2
*
*/

```

### Approach 3: 2 Pass (Space Optimization)

```cpp
// Intuition: We don't need to store 'b' counts; we can compute them while iterating through the final pass.
// Approach: Precompute 'a' counts from right. Then traverse from left, maintaining current 'b' count and updating minimum deletions.
// Time Complexity: O(2*n) -> O(n).
// Space Complexity: O(n) for one auxiliary array.

class Solution {
public:
    int minimumDeletions(string s) {
        int n      = s.length();
        
        vector<int> right_a(n, 0);

        // Pass 1: Precompute 'a' counts from the right
        int counta = 0;
        for(int i = n-1; i >= 0; i--) {
            right_a[i] = counta;
            if(s[i] == 'a')
                counta++;
        }

        int count = INT_MAX;
        int countb = 0;

        // Pass 2: Compute left 'b's on the fly and find min cost
        for(int i = 0; i < n; i++) {
            count = min(count, countb + right_a[i]);
            if(s[i] == 'b')
                countb++;
        }

        return count;

    }
};

/*
*
* Dry Run
* Input: "aab"
* Pass 1 (right_a): [1, 0, 0]
* Pass 2:
* i=0 (s[i]='a'): count = min(MAX, 0 + 1) = 1. countb remains 0.
* i=1 (s[i]='a'): count = min(1, 0 + 0) = 0. countb remains 0.
* i=2 (s[i]='b'): count = min(0, 0 + 0) = 0. countb becomes 1.
* Result: 0
*
*/

```

### Approach 4: Constant Space

```cpp
// Intuition: We can count total 'a's first. Then, as we move left-to-right, we know remaining 'a's (right) and accumulated 'b's (left) using simple variables.
// Approach: Count all 'a's. Iterate string: decrement right 'a' count if current is 'a', update min cost, increment left 'b' count if current is 'b'.
// Time Complexity: O(2*n) -> O(n).
// Space Complexity: O(1) as no extra arrays are used.

class Solution {
public:
    int minimumDeletions(string s) {
        int n      = s.length();

        // Pass 1: Count total 'a's in the string (initially all on the right)
        int counta = 0;
        for(int i = n-1; i >= 0; i--) {
            if(s[i] == 'a')
                counta++;
        }

        int count = INT_MAX;
        int countb = 0;

        // Pass 2: Iterate, moving partition from left to right
        for(int i = 0; i < n; i++) {
            // If current char is 'a', it moves from right partition to left partition
            // It is no longer an 'a' we need to delete from the right side
            if(s[i] == 'a')
                counta--;
            
            // Calculate cost: 'b's on left to delete + 'a's on right to delete
            count = min(count, countb + counta);

            // If current char is 'b', it is now part of the left partition
            // Future steps will need to delete this 'b'
            if(s[i] == 'b')
                countb++;
        }

        return count;
    }
};

/*
*
* Dry Run
* Input: s = "bbaaaaabb", n=9
* Pass 1: Total 'a's = 5. So counta = 5.
* Pass 2:
* i=0 ('b'): count = min(MAX, 0+5) = 5. countb becomes 1.
* i=1 ('b'): count = min(5, 1+5) = 6. countb becomes 2.
* i=2 ('a'): counta becomes 4. count = min(6, 2+4) = 6.
* i=3 ('a'): counta becomes 3. count = min(6, 2+3) = 5.
* i=4 ('a'): counta becomes 2. count = min(5, 2+2) = 4.
* i=5 ('a'): counta becomes 1. count = min(4, 2+1) = 3.
* i=6 ('a'): counta becomes 0. count = min(3, 2+0) = 2.
* i=7 ('b'): count = min(2, 2+0) = 2. countb becomes 3.
* i=8 ('b'): count = min(2, 3+0) = 2. countb becomes 4.
* Result: 2
*
*/

```

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)