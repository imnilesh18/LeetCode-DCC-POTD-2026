# 696. Count Binary Substrings

<p align="center">
  <a href="https://leetcode.com/problems/count-binary-substrings/description/">
    <img src="https://img.shields.io/badge/LeetCode-696-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 696" />
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Easy" />
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white" alt="C++" />
</p>

## üìã Problem Statement

Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

---

## ‚öôÔ∏è Constraints

- `1 <= s.length <= 10^5`
- `s[i]` is either `'0'` or `'1'`.

---

## üîç Examples

<details>
<summary><strong>Example 1</strong></summary>

> **Input:** `s = "00110011"`
> 
> **Output:** `6`
> 
> **Explanation:** > There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
> Notice that some of these substrings repeat and are counted the number of times they occur.
> Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.

</details>

<details>
<summary><strong>Example 2</strong></summary>

> **Input:** `s = "10101"`
> 
> **Output:** `4`
> 
> **Explanation:** > There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.

</details>

---

## üí° Key Insights & Approach

The core of this problem lies in identifying groups of consecutive characters and comparing their lengths.

1.  **Grouping Strategy:** A valid substring like `0011` is formed by a group of `0`s followed by a group of `1`s (or vice versa).
2.  **The Count:** If we have a group of `N` consecutive `0`s followed by `M` consecutive `1`s, the number of valid substrings we can form involving these two groups is `min(N, M)`.
    * Example: `00011` (3 zeros, 2 ones). We can form `01` and `0011`. The count is `min(3, 2) = 2`.
3.  **Linear Scan (Single Pass):**
    * We don't need to store all group lengths. We only need the length of the **previous** group (`prev`) and the **current** group (`curr`).
    * As we traverse the string, if the character changes (e.g., from `0` to `1`), we know the current group has ended. We add `min(prev, curr)` to our result.
    * Then, the `current` group becomes the `previous` group, and we start counting the new character.

---

## üíª Solution Code

```cpp
// Intuition: We track adjacent groups of identical characters. The number of valid substrings between two groups is min(length_of_prev_group, length_of_curr_group).
// Approach: Linear Traversal with two variables (prev, curr) to count consecutive characters. Update result when the character changes.
// Time Complexity: O(n) - We iterate through the string exactly once.
// Space Complexity: O(1) - Only a few variables used for tracking counts.

class Solution {
public:
    int countBinarySubstrings(string s) {
        int n = s.length();
        
        int result  = 0;
        int prev = 0; // Stores count of the previous consecutive block
        int curr = 1; // Stores count of the current consecutive block
        
        for(int i = 1; i < n; i++) {
            if(s[i-1] != s[i]) {
                // Determine valid substrings between the previous and current block
                result += min(prev, curr);
                
                // Shift windows: current becomes previous, reset current
                prev = curr;
                curr = 1;
            } else {
                curr++; // Continue counting the current block
            }
        }
        
        // Don't forget to account for the last pair of blocks after the loop
        return result + min(prev, curr);
    }
};

/*
*
* Dry Run
* Input: s = "00110"
* Initial: result = 0, prev = 0, curr = 1
*
* i = 1: s[0]('0') == s[1]('0') -> curr = 2
* i = 2: s[1]('0') != s[2]('1') -> result += min(0, 2) = 0. prev = 2, curr = 1
* i = 3: s[2]('1') == s[3]('1') -> curr = 2
* i = 4: s[3]('1') != s[4]('0') -> result += min(2, 2) = 2. prev = 2, curr = 1
* End Loop.
* Final Return: result + min(prev, curr) => 2 + min(2, 1) = 3.
* Total Valid Substrings: 3 ("01", "0011", "10")
*
*/
```

---

## üõ†Ô∏è Further Exploration

- **Space Optimization:** The problem can also be solved by creating an array of grouped counts (e.g., `s = "00110011"` -> `groups = [2, 2, 2, 2]`) and summing `min(groups[i], groups[i+1])`. The current solution optimizes this to O(1) space.
- **Related Problems:**
    - [Encode and Decode Strings](https://leetcode.com/problems/encode-and-decode-strings/)
    - [String Compression](https://leetcode.com/problems/string-compression/)

---

## üè∑Ô∏è Tags
`String` `Two Pointers` `Simulation`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-binary-substrings/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)