# 3713. Longest Balanced Substring I

<p align="center">
  <a href="[https://leetcode.com/problems/longest-balanced-substring-i/](https://leetcode.com/problems/longest-balanced-substring-i/)">
    <img src="[https://img.shields.io/badge/LeetCode-3713-FFA116?style=for-the-badge&logo=leetcode&logoColor=white](https://img.shields.io/badge/LeetCode-3713-FFA116?style=for-the-badge&logo=leetcode&logoColor=white)" alt="LeetCode Problem">
  </a>
  <a href="[https://github.com/imnilesh18](https://github.com/imnilesh18)">
    <img src="[https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github&logoColor=white](https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github&logoColor=white)" alt="Author">
  </a>
  <img src="[https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge](https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge)" alt="Difficulty">
  <img src="[https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white](https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white)" alt="Language">
</p>

<p align="center">
  <i>"Don't wait for inspiration to find you. Work until your results become your inspiration and others' inspiration as well."</i>
</p>

---

## ğŸ“ Table of Contents

- [ğŸ§ Problem Statement](#-problem-statement)
- [ğŸ›‘ Constraints](#-constraints)
- [ğŸ§© Examples](#-examples)
- [ğŸ’¡ Approach](#-approach)
- [ğŸ’» Solution Code](#-solution-code)
- [ğŸ“„ License](#-license)
- [ğŸ‘¨â€ğŸ’» Author](#-author)

---

## ğŸ§ Problem Statement

You are given a string `s` consisting of lowercase English letters.

A **substring** of `s` is called **balanced** if all **distinct** characters in the substring appear the **same** number of times.

Return the *length* of the **longest balanced substring** of `s`.

**Link to Problem:** [LeetCode 3713. Longest Balanced Substring I](https://leetcode.com/problems/longest-balanced-substring-i/)

---

## ğŸ›‘ Constraints

- `1 <= s.length <= 1000`
- `s` consists of lowercase English letters.

---

## ğŸ§© Examples

### Example 1
> **Input:** `s = "abbac"`
>
> **Output:** `4`
>
> **Explanation:** The longest balanced substring is `"abba"` because both distinct characters `'a'` and `'b'` each appear exactly 2 times.

### Example 2
> **Input:** `s = "zzabccy"`
>
> **Output:** `4`
>
> **Explanation:** The longest balanced substring is `"zabc"` because the distinct characters `'z'`, `'a'`, `'b'`, and `'c'` each appear exactly 1 time.

### Example 3
> **Input:** `s = "aba"`
>
> **Output:** `2`
>
> **Explanation:** One of the longest balanced substrings is `"ab"` because both distinct characters `'a'` and `'b'` each appear exactly 1 time. Another longest balanced substring is `"ba"`.

---

## ğŸ’¡ Approach

The problem asks for the longest substring where every distinct character appears with the same frequency. Since the constraints allow $N \le 1000$, an $O(N^2)$ approach is feasible.

1.  **Iterate Substrings:** We can iterate through all possible starting positions `i` and ending positions `j` of substrings.
2.  **Track Frequency:** For each substring starting at `i`, as we extend `j` from `i` to `n-1`, we maintain a frequency count of characters encountered so far.
3.  **Check Balance:** At each step (for every valid substring `s[i...j]`), we check if the substring is "balanced".
    * A helper function iterates through the frequency array (size 26).
    * It identifies the frequency of the first non-zero character found.
    * It verifies that all other characters with non-zero frequency match this value.
4.  **Update Maximum:** If the substring is balanced, we update our maximum length found so far (`maxL`).

This approach effectively brute-forces all substrings but optimizes the frequency counting by updating it incrementally for the inner loop.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Since N is small (<= 1000), we can iterate over all possible substrings, calculate their character frequencies, and check if they are balanced.
// Approach: Nested loops to generate all substrings. Inner loop maintains a running frequency array. A helper function checks if all present characters have the same frequency.
// Time Complexity: O(N^2 * 26) ~ O(N^2) because the check function is constant time (26 chars).
// Space Complexity: O(1) as we use a fixed-size frequency array of 26 integers.

class Solution {
public:

    // Helper function to check if the current frequency map represents a balanced string
    bool checkBalanced(vector<int>& freq) {
        int common = 0; // To store the target frequency for all characters
        for(int i = 0; i < 26; i++) {
            // Skip characters that are not present in the substring
            if(freq[i] == 0) {
                continue;
            } 
            
            // If common is 0, this is the first character we see; set it as the standard
            if(common == 0) {
                common = freq[i];
            } 
            // If we encounter a character with a different frequency, it's not balanced
            else if(freq[i] != common) {
                return false;
            }
        }
        // If loop completes without returning false, all characters have the same frequency
        return true;
    }

    int longestBalanced(string s) {
        int n = s.length();
        int maxL = 0; // Stores the length of the longest balanced substring found

        // Iterate through all possible starting points of a substring
        for(int i = 0; i < n; i++) {
            vector<int> freq(26, 0); // Frequency map for the current substring window
            
            // Iterate through all possible ending points for the start index i
            for(int j = i; j < n; j++) {
                // Increment frequency of the current character s[j]
                freq[s[j] - 'a']++;

                // Check if the substring s[i...j] is balanced
                if(checkBalanced(freq)) {
                    // Update maxL if the current balanced substring is longer
                    maxL = max(maxL, j - i + 1);
                }
            }
        }
        return maxL;
    }
};

/*
*
* Dry Run
* Input: s = "abba"
*
* i = 0 ('a')
* j = 0 ('a'): freq['a']=1. Balanced? Yes (all non-zero are 1). maxL = 1.
* j = 1 ('b'): freq['a']=1, freq['b']=1. Balanced? Yes. maxL = 2.
* j = 2 ('b'): freq['a']=1, freq['b']=2. Balanced? No (1 != 2).
* j = 3 ('a'): freq['a']=2, freq['b']=2. Balanced? Yes. maxL = 4.
*
* i = 1 ('b')
* j = 1 ('b'): freq['b']=1. Balanced? Yes.
* j = 2 ('b'): freq['b']=2. Balanced? Yes.
* j = 3 ('a'): freq['b']=2, freq['a']=1. Balanced? No.
*
* ... and so on.
* Final Result: 4
*/

```

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/longest-balanced-substring-i/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)