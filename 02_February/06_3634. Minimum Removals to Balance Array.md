# 3634. Minimum Removals to Balance Array

<p align="center">
  <a href="https://leetcode.com/problems/minimum-removals-to-balance-array/">
    <img src="https://img.shields.io/badge/Link-LeetCode-orange" alt="Problem Link" />
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Medium-yellow" alt="Difficulty" />
  <img src="https://img.shields.io/badge/Tags-Array-blue" />
  <img src="https://img.shields.io/badge/Tags-Sorting-blue" />
  <img src="https://img.shields.io/badge/Tags-Sliding%20Window-blue" />
  <img src="https://img.shields.io/badge/Tags-Two%20Pointers-blue" />
</p>

## üìú Problem Statement

You are given an integer array `nums` and an integer `k`.

An array is considered **balanced** if the value of its **maximum** element is **at most** `k` times the **minimum** element.

You may remove **any** number of elements from `nums` without making it **empty**.

Return the **minimum** number of elements to remove so that the remaining array is balanced.

> **Note:** An array of size 1 is considered balanced as its maximum and minimum are equal, and the condition always holds true.

---

## üìä Examples

**Example 1:**

```text
Input: nums = [2,1,5], k = 2
Output: 1
Explanation:
Remove nums[2] = 5 to get nums = [2, 1].
Now max = 2, min = 1 and max <= min * k as 2 <= 1 * 2. Thus, the answer is 1.
```

**Example 2:**

```text
Input: nums = [1,6,2,9], k = 3
Output: 2
Explanation:
Remove nums[0] = 1 and nums[3] = 9 to get nums = [6, 2].
Now max = 6, min = 2 and max <= min * k as 6 <= 2 * 3. Thus, the answer is 2.
```

**Example 3:**

```text
Input: nums = [4,6], k = 2
Output: 0
Explanation:
Since nums is already balanced as 6 <= 4 * 2, no elements need to be removed.
```

---

## üõë Constraints

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= k <= 10^5`

---

## üß† Approach & Key Insights

### 1. Rephrasing the Problem
The problem asks us to **remove the minimum number of elements** to satisfy the condition `max <= k * min`. This is mathematically equivalent to **keeping the maximum number of elements** (finding the largest subsequence) that satisfies the condition. If `L` is the length of the largest valid subsequence, the answer is simply `n - L`.

### 2. Why Sorting?
In a subsequence problem where relative order doesn't impact the condition (we only care about the values of min and max), sorting the array allows us to treat any subsequence as a contiguous subarray.
Once sorted:
- For any window `nums[i...j]`, the **minimum** is guaranteed to be `nums[i]`.
- The **maximum** is guaranteed to be `nums[j]`.

### 3. Sliding Window Strategy
We can use a **Two Pointer / Sliding Window** approach on the sorted array:
- Expand the window by moving the right pointer `j`.
- Check if the current window `nums[i...j]` is valid: `nums[j] <= k * nums[i]`.
- If valid, update the maximum length `L`.
- If invalid (i.e., `nums[j]` is too large), shrink the window from the left by moving `i` forward until the condition holds again.

This essentially finds the longest contiguous subarray in the sorted version that satisfies the balance property.

---

## üíª Solution Code

```cpp
// Intuition: Minimize removals is equivalent to maximizing the length of the balanced subsequence. Sorting helps us treat subsequences as subarrays where nums[i] is min and nums[j] is max.
// Approach: Sort the array, then use a sliding window (two pointers) to find the longest subarray where nums[j] <= k * nums[i]. The answer is total size minus this max length.
// Time Complexity: O(N log N) due to sorting. The sliding window traversal is O(N).
// Space Complexity: O(1) or O(log N) depending on the sorting implementation stack space.

class Solution {
public:
    int minRemoval(vector<int>& nums, int k) {
        int n = nums.size();

        // Sort to easily identify min and max in a window
        sort(begin(nums), end(nums));

        int L = 1; // Tracks the max length of a balanced subarray found so far
        int minEl = nums[0];
        int maxEl = nums[0];

        int i = 0;
        int j = 0;

        // Sliding window expansion
        while(j < n) {
            minEl = nums[i]; // Min is always at the start of sorted window
            maxEl = nums[j]; // Max is always at the end of sorted window

            // If condition fails, shrink window from the left
            // Use long long to prevent overflow during multiplication
            while(i < j && maxEl > (long long)k * minEl) {
                i++;
                minEl = nums[i];
            }

            // Update the maximum valid window length found
            L = max(L, j - i + 1);
            j++;
        }
        
        // Result is total elements minus the max elements we can keep
        return n - L;
    }
};

/*
*
* Dry Run
* Input: nums = [2, 1, 5], k = 2
* * 1. Sort nums: [1, 2, 5]
* n = 3, L = 1
*
* 2. Window [0, 0]: i=0, j=0
* minEl = 1, maxEl = 1
* 1 <= 2*1 (True) -> L = max(1, 1) = 1
* j increments to 1
*
* 3. Window [0, 1]: i=0, j=1
* minEl = 1, maxEl = 2
* 2 <= 2*1 (True) -> L = max(1, 2) = 2
* j increments to 2
*
* 4. Window [0, 2]: i=0, j=2
* minEl = 1, maxEl = 5
* 5 > 2*1 (True, Invalid) -> Inner while loop runs:
* i becomes 1, minEl = 2
* 5 > 2*2 (True, Invalid) -> i becomes 2, minEl = 5
* Loop ends (i=2, j=2)
* L = max(2, 2-2+1) = 2
* j increments to 3
*
* 5. j < n (3 < 3) is False. Exit loop.
*
* 6. Return n - L = 3 - 2 = 1.
*
*/
```

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-removals-to-balance-array/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)