# 67. Add Binary

<div align="center">

| ğŸ·ï¸ **Input Format** | **Details** |
|:---:|:---|
| ğŸŒ **Problem Link** | [Add Binary](https://leetcode.com/problems/add-binary) |
| ğŸ“› **Problem Name** | Add Binary |
| ğŸ“¶ **Difficulty** | **Easy** |
| ğŸ·ï¸ **Tags** | `Math` `String` `Bit Manipulation` `Simulation` |

</div>

<br>

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/add-binary) for original content and copyright.**

---

## ğŸ§  Problem Statement

Given two binary strings `a` and `b`, return *their sum as a binary string*.

### ğŸ”’ Constraints

- `1 <= a.length, b.length <= 10^4`
- `a` and `b` consist only of `'0'` or `'1'` characters.
- Each string does not contain leading zeros except for the zero itself.

---

## ğŸ§ª Examples

| Example | Input | Output |
|:---:|:---|:---|
| **1** | `a = "11"`, `b = "1"` | `"100"` |
| **2** | `a = "1010"`, `b = "1011"` | `"10101"` |

---

## ğŸ’¡ Approach

The problem asks us to perform binary addition on two strings. Just like decimal addition, we process the digits from right to left (least significant bit to most significant bit).

**Key Logic:**
1.  **Pointers**: Use two pointers, `m` and `n`, pointing to the last characters of strings `a` and `b` respectively.
2.  **Carry**: Maintain a `carry` variable (initially 0) to store the overflow from the previous bit addition.
3.  **Iteration**: Loop while either string has digits left (`m >= 0` or `n >= 0`) or there is a remaining `carry`.
4.  **Summation**:
    -   Start with `sum = carry`.
    -   If pointers are valid, add the integer value of the current characters (`'1'` becomes `1`, `'0'` becomes `0`) to `sum`.
5.  **Result Construction**:
    -   The current bit to append to the result is `sum % 2` (e.g., if sum is 2 (binary `10`), write `0`; if sum is 3 (binary `11`), write `1`).
    -   The new carry is `sum / 2` (e.g., if sum is 2 or 3, carry becomes 1).
6.  **Finalizing**: Since we append digits to the back, the result string is in reverse order. Reverse it at the end to get the correct binary sum.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Simulate binary addition bit-by-bit from right to left, handling the carry just like elementary math addition.
// Approach: Use two pointers starting from the end of strings. Compute sum = digitA + digitB + carry. Append sum % 2 to result, update carry = sum / 2. Finally reverse.
// Time Complexity: O(max(N, M)) where N and M are lengths of strings a and b. We iterate through the longer string once.
// Space Complexity: O(1) auxiliary space (excluding the space for the result string).

class Solution {
public:
    string addBinary(string a, string b) {
        int m = a.length() - 1; // Pointer for string a
        int n = b.length() - 1; // Pointer for string b

        string result = "";
        int sum = 0;
        int carry = 0; // Initialize carry

        // Iterate while there are digits in a or b
        while(m >= 0 || n >= 0) {
            sum = carry; // Start sum with previous carry

            // Add digit from a if available
            if(m >= 0) {
                sum += a[m] - '0'; // Convert char to int
                m--;
            }

            // Add digit from b if available
            if(n >= 0) {
                sum += b[n] - '0'; // Convert char to int
                n--;
            }

            // Append the resulting bit (0 or 1)
            result.push_back((sum % 2 == 0) ? '0' : '1');

            // Update carry for next position (1 if sum >= 2)
            carry = (sum > 1) ? 1 : 0; // sum / 2
        }

        // If carry remains after loop, append it
        if(carry) {
            result.push_back('1');
        }

        // Result is constructed backwards, reverse it
        reverse(begin(result), end(result));

        return result;
    }
};

/*
*
* Dry Run
* Input: a = "11", b = "1"
* m = 1, n = 0, carry = 0, result = ""
*
* Iteration 1:
* m=1 ('1'), n=0 ('1')
* sum = 0 (carry) + 1 (a[1]) + 1 (b[0]) = 2
* result push: (2 % 2 == 0) -> '0'. result = "0"
* carry = (2 > 1) -> 1
* m becomes 0, n becomes -1
*
* Iteration 2:
* m=0 ('1'), n=-1 (skip)
* sum = 1 (carry) + 1 (a[0]) = 2
* result push: (2 % 2 == 0) -> '0'. result = "00"
* carry = (2 > 1) -> 1
* m becomes -1
*
* Loop ends (m=-1, n=-1).
* Final check: carry is 1.
* result push '1'. result = "001"
*
* Reverse result: "001" -> "100"
* Return "100"
*
*/

```

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)
