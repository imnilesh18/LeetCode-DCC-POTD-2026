# 3379. Transformed Array

<div align="center">

[<img src="https://img.shields.io/badge/Problem-Transformed%20Array-blue?style=for-the-badge&logo=leetcode" alt="LeetCode Link">](https://leetcode.com/problems/transformed-array/)

<img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Easy">

<img src="https://img.shields.io/badge/Tags-Array%20|%20Simulation%20|%20Modular%20Arithmetic-grey?style=for-the-badge" alt="Tags">

<img src="https://img.shields.io/badge/License-MIT-green?style=for-the-badge" alt="License">

</div>

---

## üìù Problem Statement

You are given an integer array `nums` that represents a **circular** array. Your task is to create a new array `result` of the **same** size, following these rules:

For each index `i` (where `0 <= i < nums.length`), perform the following **independent** actions:
1.  If `nums[i] > 0`: Start at index `i` and move `nums[i]` steps to the **right** in the circular array. Set `result[i]` to the value of the index where you land.
2.  If `nums[i] < 0`: Start at index `i` and move `abs(nums[i])` steps to the **left** in the circular array. Set `result[i]` to the value of the index where you land.
3.  If `nums[i] == 0`: Set `result[i]` to `nums[i]`.

Return the new array `result`.

> **Note:** Since `nums` is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.

---

## üîí Constraints

- `1 <= nums.length <= 100`
- `-100 <= nums[i] <= 100`

---

## üî¢ Examples

### Example 1

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [3,-2,1,1]` | `[1,1,1,3]` | - `nums[0] (3)`: Move 3 steps right from index 0 -> index 3. Value is `1`.<br>- `nums[1] (-2)`: Move 2 steps left from index 1 -> index 3 (circular). Value is `1`.<br>- `nums[2] (1)`: Move 1 step right from index 2 -> index 3. Value is `1`.<br>- `nums[3] (1)`: Move 1 step right from index 3 -> index 0. Value is `3`. |

### Example 2

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [-1,4,-1]` | `[-1,-1,4]` | - `nums[0] (-1)`: Move 1 step left from index 0 -> index 2. Value is `-1`.<br>- `nums[1] (4)`: Move 4 steps right from index 1 -> index 2 (4 % 3 = 1 step). Value is `-1`.<br>- `nums[2] (-1)`: Move 1 step left from index 2 -> index 1. Value is `4`. |

---

## üí° Explanation

This problem asks us to simulate movement in a circular array. The core challenge is calculating the correct destination index after moving a specific number of steps (`nums[i]`) from a starting index (`i`), considering that the array wraps around.

The standard formula for circular indexing is:
$$\text{newIndex} = (i + \text{steps}) \pmod n$$

However, there are two nuances:
1.  **Large Steps:** The number of steps (`nums[i]`) might be larger than the array size (`n`). Moving `n` steps brings us back to the same position. Therefore, we effectively only move `nums[i] % n` steps.
2.  **Negative Steps (Moving Left):** In programming (specifically C++), the modulo operator `%` can return negative values for negative inputs. For example, `-1 % 4` might result in `-1`. To handle circular wrapping correctly for negative indices (e.g., going left from index 0 should take you to index `n-1`), we need to adjust the result.

**The Strategy:**
1.  Initialize a `result` array of size `n`.
2.  Iterate through each index `i` from `0` to `n-1`.
3.  Calculate the raw `shift` amount: `nums[i] % n`. This handles large values efficiently.
4.  Calculate the potential `newIndex`: `(i + shift) % n`.
5.  **Handle Negative Indices:** If `newIndex` is negative (which happens when moving left past index 0), simply add `n` to it. This effectively "wraps" the negative index to the end of the array.
6.  Assign the value at `nums[newIndex]` to `result[i]`.

This approach ensures we handle both direction and large magnitudes in `O(1)` time per element.

---

## üíª Solution Code

```cpp
// Intuition: The problem requires mapping each index to a new one based on circular shifts. Modular arithmetic is the natural tool for wrapping around arrays.
// Approach: Iterate through the array, calculating the target index for each element using (i + nums[i]) % n. Handle potential negative indices from left shifts by adding 'n'.
// Time Complexity: O(N) where N is the number of elements in the array (we iterate once).
// Space Complexity: O(1) auxiliary space (excluding the result array required for output).

class Solution {
public:
    vector<int> constructTransformedArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, 0);

        for(int i = 0; i < n; i++) {
            // Normalize the shift distance to be within array bounds [-n, n]
            int shift = nums[i] % n; 

            // Calculate new index with wrap-around logic
            int newIndex = (i + shift) % n;
            
            // Handle negative indices resulting from left moves
            if(newIndex < 0) {
                newIndex += n;
            }

            // Assign value from the calculated destination
            result[i] = nums[newIndex];
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [3, -2, 1, 1], n = 4
*
* Iteration 1 (i = 0):
* nums[0] = 3
* shift = 3 % 4 = 3
* newIndex = (0 + 3) % 4 = 3
* newIndex >= 0, so no change
* result[0] = nums[3] = 1
*
* Iteration 2 (i = 1):
* nums[1] = -2
* shift = -2 % 4 = -2
* newIndex = (1 - 2) % 4 = -1
* newIndex < 0, so newIndex = -1 + 4 = 3
* result[1] = nums[3] = 1
*
* Iteration 3 (i = 2):
* nums[2] = 1
* shift = 1 % 4 = 1
* newIndex = (2 + 1) % 4 = 3
* newIndex >= 0, so no change
* result[2] = nums[3] = 1
*
* Iteration 4 (i = 3):
* nums[3] = 1
* shift = 1 % 4 = 1
* newIndex = (3 + 1) % 4 = 0
* newIndex >= 0, so no change
* result[3] = nums[0] = 3
*
* Output: [1, 1, 1, 3]
*/

```

---

## üìù Notes

* **Modulo Operator behavior:** In C++, `-2 % 5` results in `-2`. In Python, it results in `3`. This is why the check `if (newIndex < 0) newIndex += n;` is crucial in C++ to achieve mathematical canonical modulo behavior for circular arrays.
* **Optimization:** Normalizing the shift using `nums[i] % n` at the start prevents potential integer overflows if `i + nums[i]` were extremely large, though constraints here (`-100` to `100`) are small enough. It's good practice for scalability.

---

## üóùÔ∏è Key Insights

1. **Circular Array = Modular Arithmetic**: Whenever a problem mentions "circular array" or "wrapping around," think of the modulo operator (`%`).
2. **Index Handling**: `(current_index + steps) % size` calculates forward movement. For backward movement, ensure the result is non-negative.
3. **Independence**: Each calculation is independent of others; changes don't cascade, allowing for a simple single-pass solution.

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/transformed-array/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
