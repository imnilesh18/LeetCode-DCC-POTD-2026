# 961. N-Repeated Element in Size 2N Array

<div align="center">

[![Time Complexity](https://img.shields.io/badge/Time%20Complexity-O(N)-blue?style=for-the-badge&logo=clock)](https://github.com/imnilesh18)
[![Space Complexity](https://img.shields.io/badge/Space%20Complexity-O(1)-green?style=for-the-badge&logo=memory)](https://github.com/imnilesh18)
[![Difficulty](https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/description/)

</div>

---

## üîó Problem Link

[**LeetCode: N-Repeated Element in Size 2N Array**](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/description/)

## üí° Problem Statement

You are given an integer array `nums` with the following properties:

- `nums.length == 2 * n`.
- `nums` contains `n + 1` unique elements.
- Exactly one element of `nums` is repeated `n` times.

Return *the element that is repeated `n` times*.

## üßê Constraints

- `2 <= n <= 5000`
- `nums.length == 2 * n`
- `0 <= nums[i] <= 10^4`
- `nums` contains `n + 1` unique elements and one of them is repeated exactly `n` times.

## üìù Examples

| Example | Input | Output | Explanation |
|:---:|:---:|:---:|:---|
| **1** | `nums = [1,2,3,3]` | `3` | `n = 2`. The array length is 4. `3` appears twice. |
| **2** | `nums = [2,1,2,5,3,2]` | `2` | `n = 3`. The array length is 6. `2` appears three times. |
| **3** | `nums = [5,1,5,2,5,3,5,4]` | `5` | `n = 4`. The array length is 8. `5` appears four times. |

---

## üß† Approach & Intuition

The problem guarantees that in an array of size `2N`, one element repeats `N` times, and the remaining `N` elements are unique (appearing exactly once). This density of the repeated element allows for several strategies:

1.  **Counting (Brute Force):** Count the frequency of every number. The one with count `N` is the answer.
2.  **First Duplicate (Hash Map/Set):** Since unique elements appear only once, the *first* number we see for the second time **must** be the repeated element. We don't need to wait for the count to reach `N`.
3.  **Pattern Matching (O(1) Space):** By the Pigeonhole Principle, if an element occupies half the array, it must appear frequently enough to be adjacent to itself or have only one element between instances.

---

## üíª Solution Code

### 1Ô∏è‚É£ Approach 1: Brute Force (Counting Frequencies)

```cpp
// Intuition: Count the occurrence of every number to find the one that appears N times.
// Approach: Use a Hash Map to store frequencies of all elements, then iterate to find the target count.
// Time Complexity: O(N) - We iterate through the array twice (once to fill map, once to check).
// Space Complexity: O(N) - Storing frequencies for N+1 unique elements.

class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        int n = nums.size(); // This is effectively 2N in the problem description
        unordered_map<int, int> mp;

        for(int i = 0; i < n; i++) {
            mp[nums[i]]++; // Count frequencies of all elements
        }

        // Fix: iterate over pairs using 'auto'
        for(auto &it : mp) {
            // it.first is the number, it.second is the count
            // Since nums.size() is 2N, the target count is n/2
            if(it.second == n / 2) { 
                return it.first; // Return the number, not the count
            }
        }
        return 0;
    }
};

/*
*
* Dry Run
* Input: nums = [1, 2, 3, 3] (Size 4, so N=2)
* 1. Loop 1: Map fills -> {1:1, 2:1, 3:2}
* 2. Loop 2: Check pairs
* - Check 1: count is 1 != 2
* - Check 2: count is 1 != 2
* - Check 3: count is 2 == 2 -> Return 3
*
*/

```

### 2Ô∏è‚É£ Approach 2: Hash Map (Early Exit)

```cpp
// Intuition: The repeated element is the only one that appears more than once. We can stop as soon as we find a duplicate.
// Approach: Iterate through the array, update count in map, and check if count > 1 immediately.
// Time Complexity: O(N) - We stop as soon as we find the repeated element (often much earlier than N).
// Space Complexity: O(N) - In worst case, we might store N unique elements before finding the duplicate.

class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        unordered_map<int, int> mp;
        
        for (int num : nums) {
            mp[num]++; // Increment count
            // If we've seen this number before, it must be the answer
            if (mp[num] > 1) {
                return num; // Found the repeated element immediately
            }
        }
        return -1;
    }
};

/*
*
* Dry Run
* Input: nums = [2, 1, 2, 5]
* 1. num = 2: mp[2] = 1. (1 is not > 1)
* 2. num = 1: mp[1] = 1. (1 is not > 1)
* 3. num = 2: mp[2] becomes 2. (2 > 1) -> Return 2
*
*/

```

### 3Ô∏è‚É£ Approach 3: Hash Set (Optimized Storage)

```cpp
// Intuition: Similar to Approach 2, but using a Set is logically cleaner since we only care about existence, not the exact count.
// Approach: Check if number exists in Set. If yes, return it. If no, insert it.
// Time Complexity: O(N) - Average case insert/find in set is O(1).
// Space Complexity: O(N) - To store unique elements.

class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        unordered_set<int> st;
        
        for (int &num : nums) {
            if(st.count(num)) // Check if seen before
                return num;
            
            st.insert(num); // Mark as seen
        }
        
        return -1;
    }
};

/*
*
* Dry Run
* Input: nums = [5, 1, 5, 2]
* 1. num = 5: Not in set. Insert 5. Set: {5}
* 2. num = 1: Not in set. Insert 1. Set: {5, 1}
* 3. num = 5: Found in set! Return 5.
*
*/

```

### 4Ô∏è‚É£ Approach 4: Frequency Array (Small Constraint Optimization)

```cpp
// Intuition: Since values are limited to 10^4, a fixed-size array is faster and avoids hash collisions overhead.
// Approach: Use a static vector as a direct address table. Return the first number with frequency > 1.
// Time Complexity: O(N) - Single pass.
// Space Complexity: O(1) - Constant size array (size 10001) regardless of N.

class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {    
        vector<int> freq(10001, 0); // Size covers range 0 to 10000
        
        for (int &num : nums) {
            freq[num]++;
            if (freq[num] > 1) // all other elements appear exactly once
                return num;
        }
        
        return -1;
    }
};

/*
*
* Dry Run
* Input: nums = [9, 6, 9, 2]
* 1. num = 9: freq[9] = 1
* 2. num = 6: freq[6] = 1
* 3. num = 9: freq[9] = 2. Check (2 > 1) -> Return 9
*
*/

```

### 5Ô∏è‚É£ Approach 5: Pattern Checking (True O(1) Space)

```cpp
// Intuition: The repeated element occupies 50% of the array. By Pigeonhole Principle, duplicate instances must be close (distance 1 or 2).
// Approach: Check neighbors (i vs i-1) and gap-neighbors (i vs i-2). If loop finishes, return the last element (corner case).
// Time Complexity: O(N) - Single pass.
// Space Complexity: O(1) - No auxiliary data structure used.

class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        int n = nums.size();
        
        for(int i = 2; i < n; i++) {
            // Check immediate neighbor or neighbor's neighbor
            if(nums[i] == nums[i-1] || nums[i] == nums[i-2])
                return nums[i];
        }
        
        return nums[n-1]; // Corner case for small arrays like [1, 2, 3, 1]
    }
};

/*
*
* Dry Run
* Input: nums = [1, 2, 3, 1]
* 1. i = 2 (val 3): 3!=2 (i-1), 3!=1 (i-2).
* 2. i = 3 (val 1): 1!=3 (i-1), 1==1 (i-2). Return 1.
*
* Input: nums = [2, 1, 2, 5]
* 1. i = 2 (val 2): 2!=1 (i-1), 2==2 (i-2). Return 2.
*
*/

```

---

## üîç Key Insights

1. **Unique Property:** The problem guarantees only **one** element repeats. This simplifies the logic from "finding element with frequency N" to simply "finding the first duplicate".
2. **Density:** Because the target element appears `N` times in `2N` slots, the probability of two instances being far apart is zero.
3. **Space Trade-offs:**
* **Hash Set:** Cleanest logic, O(N) space.
* **Freq Array:** Best runtime in practice due to memory locality, technically constant space (10KB).
* **Pattern Check:** Cleverest mathematical observation, effectively zero extra memory.



---

## üè∑Ô∏è Tags

`Array` `Hash Table` `Counting` `Pigeonhole Principle` `Math`

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/description/) for original content and copyright.**
