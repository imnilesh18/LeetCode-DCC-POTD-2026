# 85. Maximal Rectangle

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximal-rectangle/description/) for original content and copyright.**

## üîó Problem Link
[LeetCode - Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/)

## ‚ÑπÔ∏è Problem Name
Maximal Rectangle

## üè∑Ô∏è Difficulty
Hard


---

## ‚ùì Problem Statement

Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return *its area*.

## üéØ Constraints

- `rows == matrix.length`
- `cols == matrix[i].length`
- `1 <= rows, cols <= 200`
- `matrix[i][j]` is `'0'` or `'1'`.

## üìù Examples

| Example | Input | Output | Explanation |
| :-: | :-: | :-: | :-- |
| **1** | `matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]` | `6` | The maximal rectangle is shown in the explanation image (covering the 1s). |
| **2** | `matrix = [["0"]]` | `0` | No 1s are present. |
| **3** | `matrix = [["1"]]` | `1` | Single cell rectangle. |

---

## üí° Approach

The problem asks for the largest rectangle of 1s in a 2D binary matrix. This can be visualized as finding the **Largest Rectangle in a Histogram** multiple times.

1.  **Reduce 2D to 1D**: We treat each row of the matrix as the base of a histogram.
2.  **Accumulate Heights**: As we iterate through the rows, we build a `height` array.
    * If `matrix[row][col] == '1'`, we add 1 to the height from the previous row (`height[col] += 1`).
    * If `matrix[row][col] == '0'`, the height resets to 0 (`height[col] = 0`), because a rectangle cannot span across a zero.
3.  **Calculate Max Area**: For every updated row (which now represents a histogram), we calculate the maximum rectangular area using the **Monotonic Stack** technique (Next Smaller Element).
    * We find the **Next Smaller Element to the Left (NSL)** and **Next Smaller Element to the Right (NSR)** for every bar in the histogram.
    * The width of the rectangle for a bar at index `i` is `(NSR[i] - NSL[i] - 1)`.
    * Area = `height[i] * width`.
4.  **Update Global Maximum**: We track the maximum area found across all rows.

### Key Algorithms Used:
* **Monotonic Stack**: To find NSL and NSR efficiently in O(N).
* **Histogram Area**: Applying the logic to each row.

---

## üíª Solution Code

```cpp
// Intuition: Convert each row into a histogram and find the largest rectangle area using Monotonic Stack (Next Smaller Element).
// Approach: Iterate rows, update cumulative heights (reset on '0'), and calculate max area for the current row's histogram.
// Time Complexity: O(R * C) - We traverse each cell once, and histogram calculation takes O(C).
// Space Complexity: O(C) - Space for height array and stacks to store indices.

class Solution {
public:

    // Helper to find the index of the Next Smaller Element to the Right
    vector<int> getNSR(vector<int>& height){
        stack<int> st;
        int n = height.size();

        vector<int> NSR(n);
        // Traverse from right to left
        for(int i = n - 1; i >= 0; i--) {
            if(st.empty()) {
                NSR[i] = n; // No smaller element on right, use 'n' as boundary
            } else {
                // Pop elements greater or equal to current height
                while(!st.empty() && height[st.top()] >= height[i]) {
                    st.pop();
                }
                if(st.empty()) {
                    NSR[i] = n;
                } else {
                    NSR[i] = st.top(); // Top is the next smaller element
                }
            }
            st.push(i);
        }
        return NSR;
    }

    // Helper to find the index of the Next Smaller Element to the Left
    vector<int> getNSL(vector<int>& height){
        stack<int> st;
        int n = height.size();

        vector<int> NSL(n);
        // Traverse from left to right
        for(int i = 0; i < n; i++) {
            if(st.empty()) {
                NSL[i] = -1; // No smaller element on left, use '-1' as boundary
            } else {
                // Pop elements greater or equal to current height
                while(!st.empty() && height[st.top()] >= height[i]) {
                    st.pop();
                }
                if(st.empty()) {
                    NSL[i] = -1;
                } else {
                    NSL[i] = st.top(); // Top is the next smaller element
                }
            }
            st.push(i);
        }
        return NSL;
    }

    // Calculates largest rectangle area in a histogram
    int findMaxArea(vector<int> &height) {
        // Width formula: NSR[i] - NSL[i] - 1
        
        vector<int> NSR = getNSR(height);
        vector<int> NSL = getNSL(height);
        
        int n = height.size();
        vector<int> width(n);

        // Calculate width for each bar
        for(int i = 0 ; i < n; i++) {
            width[i] = NSR[i] - NSL[i] - 1;
        }

        int maxArea = 0;
        
        // Calculate area for each bar and find max
        for(int i = 0; i < n; i++) {
            int a = width[i] * height[i];
            maxArea = max(maxArea, a);
        }
        return maxArea;
    }

    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) return 0; // Handle empty matrix case
        int n = matrix[0].size();

        vector<int> height(n);

        // Initialize height array with the first row
        for(int i = 0; i < n; i++) {
            height[i] = (matrix[0][i] == '1') ? 1 : 0;
        }

        // Calculate max area for the first row
        int maxArea = findMaxArea(height);

        // Iterate through remaining rows
        for(int row = 1; row < m; row++) {
            for(int col = 0; col < n; col++) {
                if(matrix[row][col] == '0') {
                    height[col] = 0; // Reset height if current cell is '0'
                } else {
                    height[col] += 1; // Accumulate height if '1'
                }
            }
            // Update global max area with the current row's histogram result
            maxArea = max(maxArea, findMaxArea(height));
        }
        return maxArea;
    }
};

/*
*
* Dry Run
* Input: matrix = [["1","0"], ["1","1"]]
* Rows = 2, Cols = 2
*
* Iteration 1 (Row 0):
* height = [1, 0]
* findMaxArea([1, 0]):
* i=0 (h=1): NSL=-1, NSR=1. Width = 1-(-1)-1 = 1. Area = 1.
* i=1 (h=0): NSL=-1, NSR=2. Width = 2-(-1)-1 = 2. Area = 0.
* maxArea = 1
*
* Iteration 2 (Row 1):
* Update heights based on matrix[1][col]:
* col 0: matrix[1][0]='1' -> height[0] += 1 -> 2
* col 1: matrix[1][1]='1' -> height[1] += 1 -> 1
* height = [2, 1]
* findMaxArea([2, 1]):
* i=0 (h=2): NSL=-1, NSR=1 (1<2). Width = 1-(-1)-1 = 1. Area = 2.
* i=1 (h=1): NSL=-1, NSR=2 (bound). Width = 2-(-1)-1 = 2. Area = 2.
* maxArea = max(1, 2) = 2
*
* Output: 2
*/

```

## üîç Key Insights

* **Problem Reduction**: The hard problem effectively becomes solving the "Largest Rectangle in Histogram" problem `R` times.
* **Histogram Maintenance**: Instead of rebuilding the histogram from scratch, we carry forward the heights. Crucially, a `0` in the matrix resets the height for that column to `0` immediately, representing a break in the "building".
* **Stack Efficiency**: Using a Monotonic Stack allows finding the Nearest Smaller Element in `O(N)` time, which is critical. A brute force approach for limits would be `O(N^2)`, making the total complexity `O(R * C^2)`, which would likely TLE. The stack reduces it to `O(R * C)`.
* **Boundary Handling**: Setting NSL to `-1` and NSR to `n` handles edge cases where the rectangle extends to the boundaries of the matrix.


## üè∑Ô∏è Tags
`Array` `Dynamic Programming` `Stack` `Matrix` `Monotonic Stack`

## üë§ Author

- [imnilesh18](https://github.com/imnilesh18)

## üìÑ License

This repository is released under the [MIT License](./LICENSE).
---