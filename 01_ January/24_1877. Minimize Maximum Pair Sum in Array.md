# 1877. Minimize Maximum Pair Sum in Array

<p align="center">
  <a href="https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/">
    <img src="https://img.shields.io/badge/LeetCode-1877-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 1877">
  </a>
  <a href="https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/">
    <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge&logo=leetcode&logoColor=black" alt="Medium Difficulty">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github&logoColor=white" alt="Author">
  </a>
</p>

---

## üîñ Problem Statement

The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest pair sum in a list of pairs.

For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the maximum pair sum would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.

Given an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:
1. Each element of `nums` is in **exactly one** pair, and
2. The **maximum pair sum** is **minimized**.

Return *the minimized maximum pair sum after optimally pairing up the elements*.

---

## ‚öôÔ∏è Constraints

| Constraint | Value |
|:---|:---|
| `n` | `nums.length` |
| Range of `n` | `2 <= n <= 10^5` |
| Parity of `n` | `n` is **even** |
| Element Value | `1 <= nums[i] <= 10^5` |

---

## üîç Examples

### Example 1

| Input | Output | Explanation |
|:---|:---:|:---|
| `nums = [3,5,2,3]` | `7` | The elements can be paired up into pairs `(3,3)` and `(5,2)`.<br>The maximum pair sum is `max(3+3, 5+2) = max(6, 7) = 7`. |

### Example 2

| Input | Output | Explanation |
|:---|:---:|:---|
| `nums = [3,5,4,2,4,6]` | `8` | The elements can be paired up into pairs `(3,5)`, `(4,4)`, and `(6,2)`.<br>The maximum pair sum is `max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8`. |

---

## üí° Approach

### Intuition
The core problem asks us to minimize the "largest" sum we can form from pairs.
Consider the largest number in the array. If we pair this largest number with another large number, their sum will be very high, potentially maximizing the overall pair sum. To counteract the impact of the largest number, the optimal strategy is to pair it with the **smallest** available number.

This suggests a greedy approach:
1.  Take the largest remaining element.
2.  Pair it with the smallest remaining element.
3.  Repeat this process for all elements.

This strategy ensures that the "weight" of larger numbers is balanced by smaller numbers, keeping the maximum sum as low as possible. This is very similar to the "Boats to Save People" problem.

### Algorithm
1.  **Sort** the array `nums` in ascending order. This places the smallest elements at the start and the largest at the end.
2.  Initialize two pointers:
    * `i` pointing to the start (smallest element).
    * `j` pointing to the end (largest element).
3.  Initialize a variable `maxSum` to 0 to keep track of the result.
4.  Iterate while `i < j`:
    * Calculate the current pair sum: `nums[i] + nums[j]`.
    * Update `maxSum` with the maximum of itself and the current pair sum.
    * Increment `i` and decrement `j` to move to the next pair (second smallest and second largest).
5.  Return `maxSum`.

---

## üíª Solution Code

```cpp
// Intuition: To minimize the maximum pair sum, we must avoid adding two large numbers together. The optimal strategy is to pair the largest remaining element with the smallest remaining element to "balance" the sum.
// Approach: 1. Sort the array in ascending order. 2. Use two pointers, one at the start and one at the end. 3. Calculate the sum of the elements at these pointers and track the maximum sum encountered. 4. Move pointers inward until they meet.
// Time Complexity: O(N log N) due to sorting.
// Space Complexity: O(1) or O(log N) depending on the internal implementation of the sorting algorithm.

class Solution {
public:
    int minPairSum(vector<int>& nums) {
        sort(begin(nums), end(nums)); // Sort to align smallest with largest
        int n = nums.size();

        int i = 0;          // Pointer to the smallest element
        int j = n - 1;      // Pointer to the largest element
        int maxSum = 0;     // Track the maximum pair sum found
        
        while(i < j) {
            int result = nums[i] + nums[j]; // Pair current smallest with current largest
            maxSum = max(maxSum, result);   // Update the minimized maximum sum
            i++; // Move start pointer inwards
            j--; // Move end pointer inwards
        }
        return maxSum;
    }
};

/*
*
* Dry Run
* Input: nums = [3,5,2,3]
* * 1. Sort Array:
* nums becomes [2, 3, 3, 5]
* n = 4
*
* 2. Initialization:
* i = 0, j = 3, maxSum = 0
*
* 3. Iteration 1:
* nums[i] (2) + nums[j] (5) = 7
* maxSum = max(0, 7) = 7
* i increments to 1, j decrements to 2
*
* 4. Iteration 2:
* nums[i] (3) + nums[j] (3) = 6
* maxSum = max(7, 6) = 7
* i increments to 2, j decrements to 1
*
* 5. Termination:
* i (2) is not < j (1), loop ends.
*
* 6. Result:
* Return 7
*/

```

---

## üß© Key Insights

* **Sorting is Key:** Sorting transforms the problem into a structure where we can deterministically pick the "best" match for the "worst" outlier (the largest number).
* **Greedy & Two Pointer:** This is a classic example of combining a greedy choice (always pair min with max) with the two-pointer technique for efficiency after sorting.
* **Minimize the Maximum:** This pattern (Min-Max) often hints at binary search or greedy sorting strategies. Here, sorting is sufficient and more efficient.

---

## üñáÔ∏è References

* **Similar Problem:** [881. Boats to Save People](https://www.google.com/search?q=https://leetcode.com/problems/boats-to-save-people/)

---

## üè∑Ô∏è Tags

`Array` `Two Pointers` `Greedy` `Sorting`

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/) for original content and copyright.**

---

## üíª Author

* [imnilesh18](https://github.com/imnilesh18)
