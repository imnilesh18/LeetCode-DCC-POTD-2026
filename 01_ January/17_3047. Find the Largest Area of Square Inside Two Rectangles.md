# 3047. Find the Largest Area of Square Inside Two Rectangles

<div align="center">

<img src="https://img.shields.io/badge/difficulty-Medium-orange?style=for-the-badge&logo=leetcode" alt="Difficulty" />
<img src="https://img.shields.io/badge/language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="Language" />

</div>

---

## üîó Problem Link

[**LeetCode Problem: Find the Largest Area of Square Inside Two Rectangles**](https://leetcode.com/problems/find-the-largest-area-of-square-inside-two-rectangles/)

## üìù Problem Statement

There exist `n` rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays `bottomLeft` and `topRight` where `bottomLeft[i] = [a_i, b_i]` and `topRight[i] = [c_i, d_i]` represent the **bottom-left** and **top-right** coordinates of the `ith` rectangle, respectively.

You need to find the **maximum** area of a **square** that can fit inside the intersecting region of at least two rectangles. Return `0` if such a square does not exist.

## üìä Constraints

- `n == bottomLeft.length == topRight.length`
- `2 <= n <= 10^3`
- `bottomLeft[i].length == topRight[i].length == 2`
- `1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7`
- `1 <= topRight[i][0], topRight[i][1] <= 10^7`
- `bottomLeft[i][0] < topRight[i][0]`
- `bottomLeft[i][1] < topRight[i][1]`

## üí° Examples

### Example 1:
**Input:** `bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]`  

<img src="https://assets.leetcode.com/uploads/2024/01/05/example12.png"/>

**Output:** `1`  
**Explanation:** A square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.

### Example 2:
**Input:** `bottomLeft = [[1,1],[1,3],[1,5]], topRight = [[5,5],[5,7],[5,9]]`  

<img src="https://assets.leetcode.com/uploads/2024/07/15/diag.png"/>

**Output:** `4`  
**Explanation:** A square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is `2 * 2 = 4`.

### Example 3:
**Input:** `bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]` 

<img src="https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample2.png"/> 

**Output:** `1`  
**Explanation:** A square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1.

### Example 4:
**Input:** `bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]`  

<img src="https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample3.png"/>

**Output:** `0`  
**Explanation:** No pair of rectangles intersect, hence, the answer is 0.

---

## üß† Approach & Explanation

The problem asks us to find the largest square that can fit into the intersection of **any two** rectangles. Since the constraints allow for `O(N^2)` complexity (N <= 1000), we can brute-force check every possible pair of rectangles to find their intersection.

### Visualizing Intersection
When two rectangles intersect, the resulting shape is always a rectangle (or empty).
To find the coordinates of this intersection rectangle:
1.  **Bottom-Left Coordinate:** The intersection starts at the maximum of the two `bottomLeft` x-coordinates and the maximum of the two `bottomLeft` y-coordinates. This is because the intersection must be "inside" both, so it starts further to the right and further up.
    * `inter_x1 = max(rect1_x1, rect2_x1)`
    * `inter_y1 = max(rect1_y1, rect2_y1)`
2.  **Top-Right Coordinate:** The intersection ends at the minimum of the two `topRight` x-coordinates and the minimum of the two `topRight` y-coordinates.
    * `inter_x2 = min(rect1_x2, rect2_x2)`
    * `inter_y2 = min(rect1_y2, rect2_y2)`

### Calculating Dimensions
Once we have the boundaries `[inter_x1, inter_y1]` and `[inter_x2, inter_y2]`:
* **Width:** `inter_x2 - inter_x1`
* **Height:** `inter_y2 - inter_y1`

If either width or height is less than or equal to 0, the rectangles do not intersect.

### Finding the Square
If we have a valid intersection rectangle with `width` and `height`, the largest square that can fit inside it is limited by the smaller dimension.
* `side = min(width, height)`

We iterate through all pairs, calculate this `side`, and keep track of the maximum `side` found. Finally, return `maxSide * maxSide`.

---

## üíª Solution Code

```cpp
// Intuition: The largest square must fit in the intersection of two rectangles. We check every pair to find the max intersection.
// Approach: Iterate all pairs, find intersection boundaries (max of lefts, min of rights), compute dimensions, find max valid square side.
// Time Complexity: O(N^2) where N is the number of rectangles. We iterate through all unique pairs.
// Space Complexity: O(1) as we only store a few variables for dimensions and the maximum side found.

class Solution {
public:
    long long largestSquareArea(vector<vector<int>>& bottomLeft, vector<vector<int>>& topRight) {
        int n = bottomLeft.size(); // Total number of rectangles

        long long maxSide = 0; // Stores the max side length of square found

        // Iterate through every unique pair of rectangles
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                
                // Calculate intersection width: min of rights - max of lefts
                // The intersection's X range is [max(x1_i, x1_j), min(x2_i, x2_j)]
                int topRightX   = min(topRight[i][0], topRight[j][0]);
                int bottomLeftX = max(bottomLeft[i][0], bottomLeft[j][0]);

                int width = topRightX - bottomLeftX;

                // Calculate intersection height: min of tops - max of bottoms
                // The intersection's Y range is [max(y1_i, y1_j), min(y2_i, y2_j)]
                int topRightY   = min(topRight[i][1], topRight[j][1]);
                int bottomLeftY = max(bottomLeft[i][1], bottomLeft[j][1]);

                int height = topRightY - bottomLeftY;

                // If valid intersection exists (positive width and height)
                if(width > 0 && height > 0) {
                    // Largest square side is limited by the smaller dimension
                    int side = min(width, height);
                    maxSide = max(maxSide, (long long)side);
                }
            }
        }

        // Return area as side * side
        return maxSide * maxSide;
    }
};

/*
*
* Dry Run
* Input: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]
* n = 3
*
* i = 0 (Rect 0: [1,1] to [3,3])
* j = 1 (Rect 1: [2,2] to [4,4])
* topRightX = min(3, 4) = 3
* bottomLeftX = max(1, 2) = 2
* width = 3 - 2 = 1
* topRightY = min(3, 4) = 3
* bottomLeftY = max(1, 2) = 2
* height = 3 - 2 = 1
* Valid intersection? Yes.
* side = min(1, 1) = 1
* maxSide = 1
*
* j = 2 (Rect 2: [3,1] to [6,6])
* topRightX = min(3, 6) = 3
* bottomLeftX = max(1, 3) = 3
* width = 3 - 3 = 0
* Valid intersection? No (width is 0).
*
* i = 1 (Rect 1: [2,2] to [4,4])
* j = 2 (Rect 2: [3,1] to [6,6])
* topRightX = min(4, 6) = 4
* bottomLeftX = max(2, 3) = 3
* width = 4 - 3 = 1
* topRightY = min(4, 6) = 4
* bottomLeftY = max(2, 1) = 2
* height = 4 - 2 = 2
* Valid intersection? Yes.
* side = min(1, 2) = 1
* maxSide = max(1, 1) = 1
*
* Final Result: maxSide * maxSide = 1 * 1 = 1
*/
```

## üóùÔ∏è Key Insights

- **Geometric Intersection:** The intersection of two aligned rectangles is determined by the range `[max(lefts), min(rights)]` for X and `[max(bottoms), min(tops)]` for Y.
- **Square Constraint:** A square fitting inside a rectangle cannot have a side length larger than the rectangle's smallest dimension (`min(width, height)`).
- **Constraints Analysis:** Since `n` is up to 1000, checking all pairs requires `1000 * 999 / 2` operations, which is roughly `5 * 10^5`. This easily fits within the standard time limit (usually ~10^8 operations per second).
- **Edge Cases:** If rectangles touch at the boundary (e.g., `width = 0`), the area is 0. The code handles this by checking `width > 0 && height > 0` (or implicitly by `min` logic if calculating side directly, though calculating valid width first is cleaner).

## üè∑Ô∏è Tags

`Array` `Math` `Geometry` `Sorting`

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-the-largest-area-of-square-inside-two-rectangles/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)