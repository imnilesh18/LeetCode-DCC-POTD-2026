# 2975. Maximum Square Area by Removing Fences From a Field

<p align="center">
  <a href="https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/">
    <img src="https://img.shields.io/badge/LeetCode-2975-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 2975" />
  </a>
  <br>
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Medium" />
  <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge" alt="C++" />
  <img src="https://img.shields.io/badge/Topic-Array-blueviolet?style=for-the-badge" alt="Array" />
  <img src="https://img.shields.io/badge/Topic-Hash%20Table-blueviolet?style=for-the-badge" alt="Hash Table" />
</p>

## üìù Problem Statement

There is a large `(m - 1) x (n - 1)` rectangular field with corners at `(1, 1)` and `(m, n)` containing some horizontal and vertical fences given in arrays `hFences` and `vFences` respectively.

Horizontal fences are from the coordinates `(hFences[i], 1)` to `(hFences[i], n)` and vertical fences are from the coordinates `(1, vFences[i])` to `(m, vFences[i])`.

Return the **maximum area** of a **square field** that can be formed by **removing** some fences (possibly none) or `-1` if it is impossible to make a square field.

Since the answer may be large, return it **modulo** `10^9 + 7`.

**Note:** The field is surrounded by two horizontal fences from the coordinates `(1, 1)` to `(1, n)` and `(m, 1)` to `(m, n)` and two vertical fences from the coordinates `(1, 1)` to `(m, 1)` and `(1, n)` to `(m, n)`. These fences **cannot** be removed.

## üß± Constraints

- `3 <= m, n <= 10^9`
- `1 <= hFences.length, vFences.length <= 600`
- `1 < hFences[i] < m`
- `1 < vFences[i] < n`
- `hFences` and `vFences` are unique.

## üîç Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `m = 4, n = 3`<br>`hFences = [2,3], vFences = [2]` | `4` | Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4. |
| **2** | `m = 6, n = 7`<br>`hFences = [2], vFences = [4]` | `-1` | It can be proved that there is no way to create a square field by removing fences. |

## üí° Approach

The core problem asks for the largest square we can form. A square is defined by equal width and height. The grid is formed by intersection points of horizontal and vertical lines.

1.  **Identify Boundaries**: The problem states the field has fixed outer fences at `1` and `m` (horizontal) and `1` and `n` (vertical). We must include these in our calculations as valid boundaries for our square.
2.  **Calculate Possible Dimensions**:
    * We can calculate all possible horizontal gaps (widths) by taking the difference between every pair of vertical fences (including the boundaries `1` and `n`).
    * Similarly, we calculate all possible vertical gaps (heights) by taking the difference between every pair of horizontal fences (including boundaries `1` and `m`).
3.  **Find Common Dimension**:
    * To form a square, we need a `width` that is exactly equal to a `height`.
    * We can store all possible `widths` in a Hash Set for efficient $O(1)$ lookup.
    * Then, we iterate through all calculated `heights`. If a height exists in our `widths` set, it means we can form a square with side length equal to that height.
4.  **Maximize**: We track the maximum side length found. If no common dimension is found, return `-1`. Otherwise, return the area (`side * side`) modulo $10^9 + 7$.

## üíª Solution Code

```cpp
// Intuition: A square requires equal width and height. We generate all possible widths from vertical fences and check if any matching height exists from horizontal fences.
// Approach: Add boundaries to fence lists, sort them, calculate all pair differences for widths (store in set), then calculate all pair differences for heights and check against the set to find max common side.
// Time Complexity: O(h^2 + v^2 + hlogh + vlogv) where h and v are the number of horizontal and vertical fences. Generating all pairs takes quadratic time.
// Space Complexity: O(v^2) to store all possible widths in the hashset.

class Solution {
public:
    int M = 1e9+7;
    int maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences) {
        // Add boundary fences for horizontal limits
        hFences.push_back(1);
        hFences.push_back(m);

        // Add boundary fences for vertical limits
        vFences.push_back(1);
        vFences.push_back(n);

        // Sort to process fences in order for difference calculation
        sort(begin(hFences), end(hFences)); 
        sort(begin(vFences), end(vFences));

        // Store all possible widths from vertical fences
        unordered_set<int> widths;
        unordered_set<int> heights; // Note: logic below uses widths set directly

        // Calculate all possible widths between every pair of vertical fences
        for(int i = 0; i < vFences.size(); i++) {
            for(int j = i+1; j < vFences.size(); j++) {
                int width = vFences[j] - vFences[i];
                widths.insert(width);
            }
        }

        int maxSide = 0;

        // Calculate all possible heights and check if a matching width exists
        for(int i = 0; i < hFences.size(); i++) {
            for(int j = i+1; j < hFences.size(); j++) {
                int height = hFences[j] - hFences[i];
                
                // If this height exists in calculated widths, we found a square
                if(widths.find(height) != widths.end()) { //found a square
                    maxSide = max(maxSide, height);
                }
            }
        }

        // If no square found return -1, else return area modulo M
        return maxSide == 0 ? -1 : (1LL * maxSide * maxSide) % M;
    }
};

/*
*
* Dry Run
* Input: m = 4, n = 3, hFences = [2,3], vFences = [2]
*
* 1. Add boundaries:
* hFences becomes [2, 3, 1, 4]
* vFences becomes [2, 1, 3]
*
* 2. Sort arrays:
* hFences = [1, 2, 3, 4]
* vFences = [1, 2, 3]
*
* 3. Calculate Widths (vFences pairs):
* Pairs (i, j):
* (1, 2) -> diff 1
* (1, 3) -> diff 2
* (2, 3) -> diff 1
* widths set = {1, 2}
*
* 4. Calculate Heights (hFences pairs) & Check:
* Pairs (i, j):
* (1, 2) -> diff 1. In set? Yes. maxSide = 1
* (1, 3) -> diff 2. In set? Yes. maxSide = 2
* (1, 4) -> diff 3. In set? No.
* (2, 3) -> diff 1. In set? Yes.
* (2, 4) -> diff 2. In set? Yes.
* (3, 4) -> diff 1. In set? Yes.
*
* 5. Result:
* maxSide is 2.
* Return (2 * 2) % 1e9+7 = 4.
*/

```

## üîë Key Insights

* **Implicit Boundaries**: The trickiest part is often forgetting the problem statement mentions fences at `1` and `m`/`n` which are not in the input arrays. These must be added manually.
* **Combinatorial Differences**: Since `hFences` and `vFences` lengths are small (), an  approach to find all pairwise differences is feasible ( operations).
* **Hash Set Lookup**: Using a Hash Set allows us to verify if a specific height corresponds to a valid width in  on average, reducing the overall matching step from quadratic to linear relative to the number of pairs.

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/) for original content and copyright.**

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
