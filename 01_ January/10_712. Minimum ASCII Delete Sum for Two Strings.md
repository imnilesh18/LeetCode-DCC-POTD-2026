# 712. Minimum ASCII Delete Sum for Two Strings

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge&logo=leetcode" alt="Difficulty Medium" />
  <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="Language C++" />
  <img src="https://img.shields.io/badge/Topic-Dynamic%20Programming-ff69b4?style=for-the-badge" alt="Dynamic Programming" />
</p>

---

## ğŸ”— Problem Link
[**LeetCode: Minimum ASCII Delete Sum for Two Strings**](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)

## ğŸ’¡ Problem Statement

Given two strings `s1` and `s2`, return *the lowest **ASCII** sum of deleted characters to make two strings equal*.

### ğŸ“ Constraints
- `1 <= s1.length, s2.length <= 1000`
- `s1` and `s2` consist of lowercase English letters.

---

## ğŸ“Š Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `s1 = "sea", s2 = "eat"` | `231` | Deleting "s" from "sea" adds 115. Deleting "t" from "eat" adds 116. Total: 231. |
| **2** | `s1 = "delete", s2 = "leet"` | `403` | Deleting "dee" from "delete" (100+101+101) and "e" from "leet" (101). Total: 403. |

---

## ğŸ§  Approach & Explanation

This problem is a variation of the **Longest Common Subsequence (LCS)** or **Edit Distance** problem. Instead of minimizing the *number* of operations, we want to minimize the **ASCII sum** of deleted characters.

We can solve this using **Dynamic Programming (Memoization)**. The core idea is to explore all possibilities at each step:

1.  **Base Case**: If one string is empty, the only option is to delete all remaining characters of the other string. The cost is the sum of ASCII values of those characters.
2.  **Match**: If characters `s1[i]` and `s2[j]` are the same, no deletion is needed. We move to the next characters (`i+1`, `j+1`) with 0 cost.
3.  **Mismatch**: If characters differ, we have two choices:
    * Delete `s1[i]`: Cost is `ASCII(s1[i])` + result of solving for rest.
    * Delete `s2[j]`: Cost is `ASCII(s2[j])` + result of solving for rest.
    * We take the **minimum** of these two options.

We use a 2D array `t[1001][1001]` to memoize the results for indices `(i, j)` to avoid re-calculating subproblems.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Minimize deletion cost by exploring choices (delete from s1 vs s2) recursively with caching.
// Approach: Dynamic Programming (Top-Down / Memoization).
// Time Complexity: O(m * n) where m and n are lengths of s1 and s2.
// Space Complexity: O(m * n) for the memoization table + recursion stack depth.

class Solution {
public:
    int m, n;
    
    // Memoization table to store results of subproblems
    int t[1001][1001];
    
    int solve(string &s1, string &s2, int i, int j) {
        // Base Case: Both strings fully processed
        if(i >= m && j >= n)
            return 0;
        
        // Return cached result if already computed
        if(t[i][j] != -1)
            return t[i][j];
        
        // If s1 is exhausted, delete remaining characters of s2
        if(i >= m) {
            return t[i][j] = s2[j] + solve(s1, s2, i, j+1);
        } 
        // If s2 is exhausted, delete remaining characters of s1
        else if(j >= n) {
            return t[i][j] = s1[i] + solve(s1, s2, i+1, j);
        }
        
        // Case 1: Characters match, no deletion cost
        if(s1[i] == s2[j])
            return t[i][j] = solve(s1, s2, i+1, j+1);
        
        // Case 2: Characters differ, try deleting from s1 or s2
        int take_s1_i = s1[i] + solve(s1, s2, i+1, j); // Delete char from s1
        int take_s2_j = s2[j] + solve(s1, s2, i, j+1); // Delete char from s2
        
        // Store and return the minimum cost path
        return t[i][j] = min(take_s1_i, take_s2_j);
    }
    
    int minimumDeleteSum(string s1, string s2) {
        m = s1.length();
        n = s2.length();
        
        // Initialize memoization table with -1
        memset(t, -1, sizeof(t));
        
        return solve(s1, s2, 0, 0);
    }
};

/*
*
* Dry Run
* Input: s1 = "sea", s2 = "eat"
* * solve(0, 0) ['s' vs 'e']: Mismatch
* Option A: Delete 's' (115) + solve(1, 0) ["ea", "eat"]
* Option B: Delete 'e' (101) + solve(0, 1) ["sea", "at"]
* * Exploring Option A (solve(1, 0)):
* 'e' == 'e': Match -> solve(2, 1) ["a", "at"]
* 'a' == 'a': Match -> solve(3, 2) ["", "t"]
* s1 empty: Delete 't' (116) -> Returns 116
* Result A path: 115 (s) + 0 (e) + 0 (a) + 116 (t) = 231
*
* Exploring Option B (solve(0, 1)):
* 's' vs 'a': Mismatch... leads to higher costs (e.g., deleting 's', 'e', 'a')
* * Final Result: min(231, ...) = 231
*
*/

```

---

## ğŸ”‘ Key Insights

* **Standard DP Pattern**: This problem fits the "Two String" DP pattern, similar to LCS.
* **Handling Exhaustion**: Crucial edge case is when one string finishes before the other; we must sum the ASCII values of the remaining tail.
* **Optimization**: Top-down is intuitive, but this can also be converted to a Bottom-Up approach using a 2D table or even space-optimized 1D arrays since we only need previous row data.

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)
