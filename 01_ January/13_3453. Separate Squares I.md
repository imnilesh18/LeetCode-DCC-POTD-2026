# 3453. Separate Squares I

<p align="center">
  <a href="https://leetcode.com/problems/separate-squares-i/">
    <img src="https://img.shields.io/badge/LeetCode-3453-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 3453" />
  </a>
  <br>
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Medium" />
  <img src="https://img.shields.io/badge/Topic-Binary%20Search-blue?style=for-the-badge" alt="Binary Search" />
  <img src="https://img.shields.io/badge/Topic-Geometry-green?style=for-the-badge" alt="Geometry" />
</p>

---

## üîó Problem Link

[**LeetCode: Separate Squares I**](https://leetcode.com/problems/separate-squares-i/)

## üí° Problem Statement

You are given a 2D integer array `squares`. Each `squares[i] = [xi, yi, li]` represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.

Find the **minimum** y-coordinate value of a horizontal line such that the total area of the squares above the line **equals** the total area of the squares below the line.

Answers within $10^{-5}$ of the actual answer will be accepted.

**Note:** Squares may overlap. Overlapping areas should be counted multiple times.

---

## üì∑ Examples

### Example 1
![Example 1](https://assets.leetcode.com/uploads/2025/01/06/4062example1drawio.png)

> **Input:** `squares = [[0,0,1],[2,2,1]]`  
> **Output:** `1.00000`  
> **Explanation:** Any horizontal line between $y = 1$ and $y = 2$ will have 1 square unit above it and 1 square unit below it. The lowest option is 1.

### Example 2
![Example 2](https://assets.leetcode.com/uploads/2025/01/15/4062example2drawio.png)

> **Input:** `squares = [[0,0,2],[1,1,1]]`  
> **Output:** `1.16667`  
> **Explanation:** > The areas are:  
> **Below the line:** $7/6 \times 2$ (Red) + $1/6$ (Blue) = $15/6 = 2.5$.  
> **Above the line:** $5/6 \times 2$ (Red) + $5/6$ (Blue) = $15/6 = 2.5$.  
> Since the areas above and below the line are equal, the output is $7/6 = 1.16667$.

---

## üõë Constraints

- $1 \le \text{squares.length} \le 5 \times 10^4$
- $\text{squares}[i] = [x_i, y_i, l_i]$
- $\text{squares}[i].\text{length} == 3$
- $0 \le x_i, y_i \le 10^9$
- $1 \le l_i \le 10^9$
- The total area of all the squares will not exceed $10^{12}$.

---

## üß† Key Insights & Approach

### 1. Intuition
The problem asks for a split point (horizontal line $y=k$) where the area above equals the area below. 
- If we move the line upwards, the area below increases (or stays same) and the area above decreases.
- If we move the line downwards, the area below decreases and the area above increases.
- This **monotonic property** suggests that we can use **Binary Search on the Answer**. We are looking for a specific $y$ value in a continuous range.

### 2. Binary Search on Answer
- **Search Space:** The lowest possible $y$ is the minimum $y_i$ of any square (or 0). The highest possible $y$ is the maximum top edge ($y_i + l_i$) of any square.
- **Check Function:** For a chosen `mid_y`, we calculate the total area of squares strictly below this line.
    - If `bottom_area >= total_area / 2.0`, it means our line is high enough to capture at least half the area. Since we want the **minimum** $y$, we try to find a valid split lower down (shift `high` to `mid_y`).
    - If `bottom_area < total_area / 2.0`, our line is too low (we haven't captured half the area yet), so we must move up (shift `low` to `mid_y`).

### 3. Handling Overlaps & Precision
- The problem states overlapping areas are counted multiple times. This simplifies things: we just iterate through every square and sum up their individual contributions to the bottom area, regardless of overlaps.
- Since the answer requires precision within $10^{-5}$, we run the binary search loop while `high - low > 1e-5`. Standard binary search (`+1` / `-1`) cannot be used for floating-point values.

---

## üìù Solution Code

```cpp
// Intuition: The problem asks for a y-coordinate splitting the total area equally. The area below a line y=k increases monotonically as k increases. This monotonicity allows us to use Binary Search on the Answer.
// Approach:
// 1. Calculate the total area of all squares.
// 2. Define the search space [low, high] for the y-coordinate. 'low' is the minimum y-coordinate, and 'high' is the maximum possible top edge (y+l).
// 3. Perform Binary Search:
//    - Calculate 'mid_y'.
//    - Compute the total area of squares lying below 'mid_y' using a helper function.
//    - If 'bottom_area' >= 'total_area / 2.0', it means the line is high enough (or too high), so we try to find a smaller valid y by moving 'high' to 'mid_y'.
//    - Otherwise, the line is too low, so we move 'low' to 'mid_y'.
// 4. Continue until the difference between 'high' and 'low' is within the required precision (1e-5).
// Time Complexity: O(N * log(Range/Precision)), where N is the number of squares. We iterate through all squares in each step of the binary search.
// Space Complexity: O(1), as we only use a few variables for storage.

class Solution {
public:
    // Helper function to calculate the area of squares below the line y = mid_y
    bool check(vector<vector<int>>& squares, double mid_y, double total) {
        double bot_area = 0;

        for(auto &square : squares) {
            double y = square[1];
            double l = square[2];

            double boty = y;
            double topy = y + l;

            if (mid_y >= topy) {
                // Case 1: The square is completely below the line mid_y
                // Add full area of the square
                bot_area += l * l;
            } else if (mid_y > boty) {
                // Case 2: The line cuts through the square
                // Add the partial area: width * height (mid_y - bottom_y)
                bot_area += (mid_y - boty) * l;
            }
            // Case 3: The square is completely above the line (mid_y <= boty), contributes 0 area.
        }

        // Return true if the bottom area is at least half the total area
        // If true, we might have found a valid y, but we look for a smaller one (move down)
        return bot_area >= total/2.0; //Is bottom area more than above ?
    }

    double separateSquares(vector<vector<int>>& squares) {
        double low   = INT_MAX;
        double high  = INT_MIN;
        double total = 0.00000;

        // Determine the range for binary search and total area
        for(auto &square : squares) {
            double x = square[0];
            double y = square[1];
            double l = square[2];
            total   += l*l; // Accumulate total area

            low  = min(low, y);       // Min possible y-coordinate
            high = max(high, y+l);    // Max possible y-coordinate (top edge)
        }

        double result_y = 0.00000;

        // Binary Search on Answer with precision 1e-5
        while(high-low > 1e-5) {
            double mid_y = low + (high-low)/2;
            
            result_y = mid_y;

            // Check if the current mid_y provides enough bottom area
            if (check(squares, mid_y, total) == true) { //bottom area is greater or equal to half
                // Valid split found, but we need the minimum y, so try shifting down
                high = mid_y;
            } else {
                // Bottom area is less than half, need to move the line up
                low = mid_y;
            }
        }

        return result_y;
    }
};

/*
*
* Dry Run
* Input: squares = [[0,0,1],[2,2,1]]
* Total Area = 1*1 + 1*1 = 2. Target Bottom Area >= 1.0.
* Range: low = 0, high = 3 (max top edge).
*
* Iteration 1:
* low=0, high=3 -> mid_y = 1.5
* check(1.5):
* Sq1 (y=0, l=1): top=1. mid_y >= top. Area += 1*1 = 1.
* Sq2 (y=2, l=1): bot=2. mid_y < bot. Area += 0.
* bot_area = 1.
* 1 >= 1.0 is True. 
* We found a valid y, but we want minimum, so shift high.
* high = 1.5.
*
* Iteration 2:
* low=0, high=1.5 -> mid_y = 0.75
* check(0.75):
* Sq1: mid_y > bot (0.75 > 0). Partial area = (0.75 - 0) * 1 = 0.75.
* Sq2: Area 0.
* bot_area = 0.75.
* 0.75 >= 1.0 is False. 
* Not enough area below, shift low.
* low = 0.75.
*
* ... Binary Search continues refining until high - low <= 1e-5 ...
*
* Ideally converges to mid_y = 1.0.
* check(1.0):
* Sq1: top=1. mid_y >= top. Area += 1.
* bot_area = 1.
* True -> high = 1.0.
*
* Final Answer approx 1.00000
*/

```

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/separate-squares-i/) for original content and copyright.**

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
