# 1339. Maximum Product of Splitted Binary Tree

<div align="center">

<img src="https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png" alt="LeetCode" width="400">

[![LeetCode](https://img.shields.io/badge/LeetCode-1339-FFA116?style=for-the-badge&logo=leetcode&logoColor=black)](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge)](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)
[![Language](https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B)](https://en.cppreference.com/w/)

</div>

---

## ğŸ”— Problem Link

[**LeetCode 1339. Maximum Product of Splitted Binary Tree**](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/)

---

## ğŸ’¡ Problem Statement

Given the `root` of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return _the maximum product of the sums of the two subtrees_. Since the answer may be too large, return it **modulo** `10^9 + 7`.

**Note** that you need to maximize the answer before taking the mod and not after taking it.

---

## ğŸ›‘ Constraints

- The number of nodes in the tree is in the range `[2, 5 * 10^4]`.
- `1 <= Node.val <= 10^4`

---

## ğŸ“ Examples

| Example |                 Input                 | Output | Explanation                                                                                   |
| :-----: | :-----------------------------------: | :----: | :-------------------------------------------------------------------------------------------- |
|  **1**  |        `root = [1,2,3,4,5,6]`         | `110`  | Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11\*10). |
|  **2**  | `root = [1,null,2,3,4,null,null,5,6]` |  `90`  | Remove the red edge and get 2 binary trees with sum 15 and 6. Their product is 90 (15\*6).    |

---

## ğŸ§  Intuition

The core problem asks us to remove _one_ edge to split the tree into two parts.
If we remove an edge connecting a child to its parent, the tree splits into:

1.  **Subtree**: The tree rooted at the child node.
2.  **Remaining Tree**: The original tree minus the subtree.

If we know the **Total Sum** of the entire tree, and we calculate the sum of a specific **Subtree**, then the sum of the **Remaining Tree** is simply:
$$ \text{Remaining Sum} = \text{Total Sum} - \text{Subtree Sum} $$

The product for that split would be:
$$ \text{Product} = \text{Subtree Sum} \times (\text{Total Sum} - \text{Subtree Sum}) $$

We just need to check this product for _every_ possible subtree in the graph and keep the maximum.

---

## ğŸ›¤ï¸ Approach

1.  **Calculate Total Sum**: First, perform a traversal (DFS) of the entire tree to calculate the sum of all node values (`totalSum`).
2.  **Calculate Subtree Sums & Find Max Product**:
    - Traverse the tree again.
    - For every node, calculate the sum of the subtree rooted at that node (`currentSubtreeSum`).
    - Calculate the product using the formula: `currentSubtreeSum * (totalSum - currentSubtreeSum)`.
    - Update the global maximum product (`maxP`) if the current product is greater.
3.  **Return Result**: Finally, return `maxP % (10^9 + 7)`. Note that the maximization happens using `long long` to avoid overflow before the modulo.

_(Optimization: We can reuse the same DFS function. In the first pass, we just compute the total sum. In the second pass, we compute sums again but this time we also update the max product logic)._

---

## ğŸ’» Solution Code

```cpp
// Intuition: Split tree implies Subtree Sum vs (Total Sum - Subtree Sum). Maximize their product.
// Approach: Two-pass DFS. 1st pass: Calculate Total Sum. 2nd pass: Calculate subtree sums and update Max Product.
// Time Complexity: O(N) - We traverse the tree twice.
// Space Complexity: O(H) - Recursion stack space, where H is the height of the tree.

class Solution {
public:

    long M = 1e9+7;
    long totalSum = 0, maxP = 0;

    int findTotalSum(TreeNode* root) {
        if(!root)
            return 0;

        // Calculate sum of left and right subtrees
        int leftSubtreeSum  = findTotalSum(root->left);
        int rightSubtreeSum = findTotalSum(root->right);

        // Current subtree sum includes root value + children sums
        int sum             = root->val + leftSubtreeSum + rightSubtreeSum;

        // Calculate product: (Current Subtree Sum) * (Remaining Tree Sum)
        // Remaining Tree Sum = Total Sum - Current Subtree Sum
        // Update maxP. Note: totalSum is 0 during the first pass, so maxP stays 0.
        maxP = max(maxP, (totalSum - sum) * sum);

        return sum;
    }

    int maxProduct(TreeNode* root) {
        if(!root)
            return 0;

        maxP = 0;

        // Pass 1: Calculate the total sum of the entire tree
        totalSum = findTotalSum(root);

        // Pass 2: Re-calculate subtree sums to find the maximum product
        // Now that 'totalSum' is populated, the logic inside findTotalSum will update maxP
        findTotalSum(root);

        return maxP % M;
    }
};

/*
*
* Dry Run
* Input: root = [1, 2, 3, 4, 5, 6]
* Tree Structure:
* 1
* / \
* 2   3
* / \ /
* 4  5 6
*
* Pass 1 (Calculate totalSum):
* - DFS traverses all nodes.
* - Subtree sum at 4: 4
* - Subtree sum at 5: 5
* - Subtree sum at 2: 2 + 4 + 5 = 11
* - Subtree sum at 6: 6
* - Subtree sum at 3: 3 + 6 = 9
* - Subtree sum at 1: 1 + 11 + 9 = 21
* - totalSum = 21
*
* Pass 2 (Calculate maxProduct):
* - Global totalSum = 21.
* - Node 4: sum=4. Product = 4 * (21-4) = 68. maxP = 68.
* - Node 5: sum=5. Product = 5 * (21-5) = 80. maxP = 80.
* - Node 2: sum=11. Product = 11 * (21-11) = 11 * 10 = 110. maxP = 110.
* - Node 6: sum=6. Product = 6 * (21-6) = 90. maxP = 110.
* - Node 3: sum=9. Product = 9 * (21-9) = 108. maxP = 110.
* - Node 1: sum=21. Product = 21 * 0 = 0. maxP = 110.
*
* Result: 110 % (1e9+7) = 110.
*
*/
```

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)
