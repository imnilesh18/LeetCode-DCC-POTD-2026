# 1458. Max Dot Product of Two Subsequences

## üîó Problem Link

[LeetCode Problem - 1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/)

## üìù Problem Name

**1458. Max Dot Product of Two Subsequences**

## üè∑Ô∏è Difficulty

> [!IMPORTANT]
> **Hard**

## üè∑Ô∏è Tags

`Array`, `Dynamic Programming`

## üí° Problem Statement

Given two arrays `nums1` and `nums2`.

Return the maximum dot product between **non-empty** subsequences of `nums1` and `nums2` with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).

## ‚õìÔ∏è Constraints

-   `1 <= nums1.length, nums2.length <= 500`
-   `-1000 <= nums1[i], nums2[i] <= 1000`

## üìä Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `nums1 = [2,1,-2,5]`, `nums2 = [3,0,-6]` | `18` | Take subsequence `[2,-2]` from `nums1` and subsequence `[3,-6]` from `nums2`. <br> Their dot product is `(2*3 + (-2)*(-6)) = 18`. |
| **2** | `nums1 = [3,-2]`, `nums2 = [2,-6,7]` | `21` | Take subsequence `[3]` from `nums1` and subsequence `[7]` from `nums2`. <br> Their dot product is `(3*7) = 21`. |
| **3** | `nums1 = [-1,-1]`, `nums2 = [1,1]` | `-1` | Take subsequence `[-1]` from `nums1` and subsequence `[1]` from `nums2`. <br> Their dot product is `-1`. |

## üß† Approach

The problem asks for the maximum dot product of two subsequences of equal length. This structure strongly suggests a Dynamic Programming approach, very similar to the **Longest Common Subsequence (LCS)** problem.

At any given pair of indices `(i, j)` where `i` is the current index in `nums1` and `j` is the current index in `nums2`, we have specific choices to make to maximize our result:

1.  **Pair `nums1[i]` and `nums2[j]`**: We calculate their product (`val`).
    * We can start a new subsequence here with just this pair.
    * We can extend an existing optimal subsequence from the remaining arrays (`solve(i+1, j+1)`).
2.  **Skip `nums1[i]`**: We move `i` forward and try to pair `nums2[j]` with a later element (`solve(i+1, j)`).
3.  **Skip `nums2[j]`**: We move `j` forward and try to pair `nums1[i]` with a later element (`solve(i, j+1)`).

We essentially explore all these possibilities. Since the problem requires **non-empty** subsequences, if we reach the end of either array (base case), we return a very small negative number to indicate an invalid (empty) path, ensuring that only valid non-empty paths contribute to the maximum calculation.

Using memoization (`t[501][501]`) allows us to store and reuse the results for states `(i, j)`, reducing the time complexity from exponential to polynomial.

## üöÄ Solution Code

```cpp
// Intuition: Similar to LCS, we decide at each step (i, j) whether to multiply current elements, combine them with future results, or skip one of them.
// Approach: Recursion with Memoization. Explore 4 paths: just current pair, current pair + future, skip i, skip j. Maximize results.
// Time Complexity: O(m * n) where m and n are lengths of nums1 and nums2. We fill a table of size m x n.
// Space Complexity: O(m * n) for the memoization table + O(m + n) for recursion stack depth.

class Solution {
public:
    int m, n;
    int t[501][501]; // Memoization table
    
    int solve(vector<int>& nums1, vector<int>& nums2, int i, int j) {
        // Base case: if we run out of elements in either array
        if(i == m || j == n)
            return -100000000; // Return large negative to ensure non-empty subsequence
        
        // Return pre-calculated result if valid
        if(t[i][j] != -1e9)
            return t[i][j];
        
        // Option 1: Calculate product of current pair
        int val = nums1[i] * nums2[j];
        
        // Option 2: Take current pair and add result from future elements
        int take_i_j = solve(nums1, nums2, i+1, j+1) + val;
        
        // Option 3: Skip current element of nums1
        int take_i = solve(nums1, nums2, i, j+1);
        
        // Option 4: Skip current element of nums2
        int take_j = solve(nums1, nums2, i+1, j);
        
        // Store and return the maximum of:
        // 1. Current pair alone (val) - handles negative future sums
        // 2. Current pair + future (take_i_j)
        // 3. Skipping i (take_i)
        // 4. Skipping j (take_j)
        return t[i][j] = max({val, take_i_j, take_i, take_j});
    }
    
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        m = nums1.size();
        n = nums2.size();
        
        // Initialize DP table with a value representing "not visited"
        // Using -1e9 assuming it's lower than any possible valid dot product
        for(int i = 0; i<501; i++) {
            for(int j = 0; j < 501; j++) {
                t[i][j] = -1e9;
            }
        }
        
        return solve(nums1, nums2, 0, 0);
    }
};

/*
*
* Dry Run
* Input: nums1 = [2, 3], nums2 = [4]
* m = 2, n = 1
*
* Call solve(0, 0)
* i=0, j=0. nums1[0]=2, nums2[0]=4.
* val = 2 * 4 = 8
* * take_i_j = solve(1, 1) + 8
* Call solve(1, 1) -> Base case (j==n) returns -1e8
* take_i_j = -1e8 + 8 (Huge Negative)
*
* take_i = solve(0, 1) -> Base case (j==n) returns -1e8
* * take_j = solve(1, 0)
* i=1, j=0. nums1[1]=3, nums2[0]=4.
* val = 3 * 4 = 12
* * take_i_j = solve(2, 1) + 12 -> Base case returns -1e8 -> Huge Negative
* take_i = solve(1, 1) -> Base case returns -1e8
* take_j = solve(2, 0) -> Base case returns -1e8
* * max(12, neg, neg, neg) = 12
* Returns 12
* * Back to solve(0, 0):
* max(val=8, take_i_j=neg, take_i=neg, take_j=12) = 12
*
* Final Answer: 12
*/

```

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/) for original content and copyright.**

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
