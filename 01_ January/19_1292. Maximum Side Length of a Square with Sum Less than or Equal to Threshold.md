# 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold

<p align="center">
  <a href="https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/">
    <img src="https://img.shields.io/badge/LeetCode-1292-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 1292" />
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Medium Difficulty" />
  <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="C++" />
</p>

<p align="center">
  <img src="https://img.shields.io/badge/Topic-Array-blue" alt="Array" />
  <img src="https://img.shields.io/badge/Topic-Binary%20Search-green" alt="Binary Search" />
  <img src="https://img.shields.io/badge/Topic-Matrix-purple" alt="Matrix" />
  <img src="https://img.shields.io/badge/Topic-Prefix%20Sum-red" alt="Prefix Sum" />
</p>

---

## üìù Problem Statement

Given a `m x n` matrix `mat` and an integer `threshold`, return *the maximum side-length of a square with a sum less than or equal to* `threshold` or return `0` if there is no such square.

### üîó Problem Link
[**LeetCode 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold**](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/)

---

## üßê Constraints

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 300`
- `0 <= mat[i][j] <= 10^4`
- `0 <= threshold <= 10^5`

---

## üí° Examples

<img src="https://assets.leetcode.com/uploads/2019/12/05/e1.png"/>

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]]`, `threshold = 4` | `2` | The maximum side length of square with sum less than 4 is 2. |
| **2** | `mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]`, `threshold = 1` | `0` | No square has a sum ‚â§ 1. |

---

## üß† Approach & Key Insights

### Key Concepts
1.  **2D Prefix Sum**: This technique allows us to calculate the sum of any sub-matrix in **O(1)** time after an **O(m*n)** preprocessing step.
    * Formula: `Sum(r1, c1, r2, c2) = Prefix[r2][c2] - Prefix[r1-1][c2] - Prefix[r2][c1-1] + Prefix[r1-1][c1-1]`.
2.  **Square Geometry**: A square is defined by its top-left corner `(i, j)` and its side length `k`. The bottom-right corner is `(i + k - 1, j + k - 1)`.

### Approach 1: 2D Prefix Sum + Smart Iteration (Optimized Brute Force)
Instead of checking every possible square size for every cell (which would be too slow), we can iterate through the matrix and try to extend the side length found *so far*.
* We maintain a variable `best` (current max side length found).
* For each cell `(i, j)`, we check if we can form a square of size `best + 1`.
* If we can, we update `best` and try larger sizes. If not, we move to the next cell.
* This avoids checking smaller squares that won't improve our answer.

### Approach 2: 2D Prefix Sum + Binary Search on Answer
The answer (side length) is monotonic. If a square of size `k` exists with sum `‚â§ threshold`, then a square of size `k-1` also satisfies the condition (conceptually). If `k` is not possible, `k+1` is definitely not possible.
* We use **Binary Search** on the side length `[1, min(m, n)]`.
* **Check Function**: For a given `mid` (side length), iterate through all possible top-left corners to see if *any* valid square exists.

---

## üíª Solution Code

### 1Ô∏è‚É£ Approach 1: 2D Prefix Sum + Smart Iteration

<details>
<summary>Click to expand C++ Code</summary>

```cpp
// Intuition: Use 2D Prefix Sum to query sub-matrix sums in O(1). Iterate through cells and greedily try to increase the 'best' found square side length.
// Approach: Build a 2D prefix sum array. Iterate through each cell (i, j) as the top-left corner. Attempt to form a square of size 'best + 1'. If valid (sum <= threshold), update 'best' and try larger sizes.
// Time Complexity: O(rows * cols * min(rows, cols)) in worst case, but practically much faster due to 'best' optimization.
// Space Complexity: O(rows * cols) for the prefix sum matrix.

class Solution {
public:
    int maxSideLength(vector<vector<int>>& mat, int threshold) {
        int rows = mat.size();
        int cols = mat[0].size();

        // Create a 2D prefix sum array initialized with 0
        vector<vector<int>> prefix(rows, vector<int>(cols, 0));

        // Build prefix sum matrix
        // prefix[i][j] stores sum of rectangle from (0,0) to (i,j)
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                prefix[i][j] = mat[i][j]
                             + (i > 0 ? prefix[i - 1][j] : 0)
                             + (j > 0 ? prefix[i][j - 1] : 0)
                             - (i > 0 && j > 0 ? prefix[i - 1][j - 1] : 0);
            }
        }

        // Helper lambda to calculate sum of any sub-matrix (square)
        // using the inclusion-exclusion principle
        auto sumSquare = [&](int i, int j, int r2, int c2) {
            int sum = prefix[r2][c2];
            if (i > 0) sum -= prefix[i - 1][c2];
            if (j > 0) sum -= prefix[r2][j - 1];
            if (i > 0 && j > 0) sum += prefix[i - 1][j - 1];
            
            return sum;
        };

        int best = 0; // Stores the maximum side length found so far

        // Iterate through each cell as the top-left corner of a potential square
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // Optimization: Start checking from size 'best' onwards.
                // We don't care about smaller squares since we want the maximum.
                // k is the offset (side length - 1)
                for (int k = best; k < min(rows - i, cols - j); k++) { //offset to find bottom right cell
                    // Calculate bottom right cell coordinates (r2, c2)
                    int r2 = i + k;
                    int c2 = j + k;

                    // Get sum of square defined by (i,j) and (r2,c2)
                    int sum = sumSquare(i, j, r2, c2);

                    if (sum <= threshold) {
                        best = k + 1; // (offset + 1) gives the side of square
                    } else {
                        break; // Since values are non-negative, larger squares will have larger sums. Stop.
                    }
                }
            }
        }

        return best;
    }
};

/*
*
* Dry Run
* Input: mat = [[1,1],[1,1]], threshold = 2
* rows = 2, cols = 2
* * Prefix Sum Construction:
* [1, 2]
* [2, 4]
*
* Iteration:
* i=0, j=0, best=0
* k=0 (size 1): sumSquare(0,0,0,0) -> 1 <= 2? Yes. best = 1.
* k=1 (size 2): sumSquare(0,0,1,1) -> 4 <= 2? No. Break.
* * i=0, j=1, best=1
* k=1 (size 2): sumSquare(0,1, 1,2) -> Out of bounds loop condition.
*
* (Loops continue, best remains 1)
* Return 1.
*
*/
```
</details>

### 2Ô∏è‚É£ Approach 2: 2D Prefix Sum + Binary Search

<details>
<summary>Click to expand C++ Code</summary>

```cpp
// Intuition: Since side lengths are monotonic (if size K works, size K-1 implicitly works for validity purposes, and if K fails, K+1 fails), we can binary search the answer.
// Approach: Build 2D Prefix Sum. Binary search on the side length 'side' from 1 to min(rows, cols). The 'check' function iterates all cells to see if ANY square of that 'side' fits the threshold.
// Time Complexity: O(rows * cols * log(min(rows, cols))) - Prefix sum takes O(MN), Binary Search takes O(log(min(M,N))), Check takes O(MN).
// Space Complexity: O(rows * cols) for the prefix sum matrix.

class Solution {
public:
    int maxSideLength(vector<vector<int>>& mat, int threshold) {
        int rows = mat.size();
        int cols = mat[0].size();

        // Build 2D prefix sum array to calculate range sums in O(1)
        vector<vector<int>> prefix(rows, vector<int>(cols, 0));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                prefix[i][j] = mat[i][j]
                             + (i > 0 ? prefix[i - 1][j] : 0)
                             + (j > 0 ? prefix[i][j - 1] : 0)
                             - (i > 0 && j > 0 ? prefix[i - 1][j - 1] : 0);
            }
        }

        // Sum of square sub-matrix defined by top-left (r1,c1) and bottom-right (r2,c2)
        auto sumSquare = [&](int r1, int c1, int r2, int c2) {
            int sum = prefix[r2][c2];
            if (r1 > 0) sum -= prefix[r1 - 1][c2];
            if (c1 > 0) sum -= prefix[r2][c1 - 1];
            if (r1 > 0 && c1 > 0) sum += prefix[r1 - 1][c1 - 1];
            return sum;
        };

        // Check function: Returns true if ANY square of 'side' length exists with sum <= threshold
        auto check = [&](int side) {
            // Iterate through all valid top-left corners for a square of size 'side'
            for (int i = 0; i + side - 1 < rows; i++) {
                for (int j = 0; j + side - 1 < cols; j++) {
                    // Check sum of the current square
                    if (sumSquare(i, j, i + side - 1, j + side - 1) <= threshold) {
                        return true; // Found at least one valid square
                    }
                }
            }
            return false; // No square of this size satisfies the condition
        };

        // Binary search on the answer (side length)
        // Range: [1, min dimension of matrix]
        int lo = 1, hi = min(rows, cols);
        int result = 0;

        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2; // 'mid' is the candidate side length
            if (check(mid)) {
                result = mid; // Possible answer, try to find a larger one
                lo = mid + 1;
            } else {
                hi = mid - 1; // Square too big (sum > threshold), try smaller size
            }
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: mat = [[2,2],[2,2]], threshold = 1
* rows = 2, cols = 2. Prefix Sum Built.
* Binary Search: lo = 1, hi = 2
* * Iteration 1:
* mid = 1 + (2-1)/2 = 1.
* check(1):
* (0,0) sum = 2 > 1
* (0,1) sum = 2 > 1
* (1,0) sum = 2 > 1
* (1,1) sum = 2 > 1
* check returns false.
* hi = mid - 1 = 0.
*
* Loop ends (lo=1, hi=0).
* Return result (0).
*
*/
```
</details>

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)