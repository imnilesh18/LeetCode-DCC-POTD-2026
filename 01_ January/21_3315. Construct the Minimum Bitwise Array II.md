# 3315. Construct the Minimum Bitwise Array II

<div align="center">

<img src="https://img.shields.io/badge/Difficulty-Medium-F2C94C?style=flat-square" alt="Difficulty Medium" />
<img src="https://img.shields.io/badge/Time_Complexity-O(N)-546E7A?style=flat-square" alt="Time Complexity O(N)" />
<img src="https://img.shields.io/badge/Space_Complexity-O(1)-546E7A?style=flat-square" alt="Space Complexity O(1)" />

<br />
<a href="https://leetcode.com/tag/array/"><img src="https://img.shields.io/badge/Tag-Array-29B6F6?style=flat-square" alt="Tag Array" /></a>
<a href="https://leetcode.com/tag/bit-manipulation/"><img src="https://img.shields.io/badge/Tag-Bit_Manipulation-29B6F6?style=flat-square" alt="Tag Bit Manipulation" /></a>
<a href="https://leetcode.com/tag/math/"><img src="https://img.shields.io/badge/Tag-Math-29B6F6?style=flat-square" alt="Tag Math" /></a>

</div>

---

## üìù Problem Statement

You are given an array `nums` consisting of `n` **prime** integers.

You need to construct an array `ans` of length `n`, such that, for each index `i`, the bitwise **OR** of `ans[i]` and `ans[i] + 1` is equal to `nums[i]`, i.e. `ans[i] OR (ans[i] + 1) == nums[i]`.

Additionally, you must **minimize** each value of `ans[i]` in the resulting array.

If it is **not possible** to find such a value for `ans[i]` that satisfies the condition, then set `ans[i] = -1`.

---

## üîó Problem Link

[**LeetCode: Construct the Minimum Bitwise Array II**](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/description/)

---

## üõë Constraints

- `1 <= nums.length <= 100`
- `2 <= nums[i] <= 10^9`
- `nums[i]` is a prime number.

---

## üß™ Examples

### Example 1

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [2,3,5,7]` | `[-1,1,4,3]` | - For `i = 0`: No `ans[0]` satisfies condition for `2`, so `-1`.<br>- For `i = 1`: `1 OR 2 = 3`. Smallest is `1`.<br>- For `i = 2`: `4 OR 5 = 5`. Smallest is `4`.<br>- For `i = 3`: `3 OR 4 = 7`. Smallest is `3`. |

### Example 2

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [11,13,31]` | `[9,12,15]` | - `9 OR 10 = 11`.<br>- `12 OR 13 = 13`.<br>- `15 OR 16 = 31`. |

---

## üí° Approach & Key Insights

### The Mathematical Property
The problem asks for `x` such that `x | (x + 1) == target`.
Let's observe what `x | (x + 1)` actually does:
1.  Adding `1` to `x` flips the **rightmost** `0` bit to `1` and flips all trailing `1`s to `0`s.
2.  Performing `OR` between `x` and `x+1` effectively **sets the rightmost `0` bit of `x` to `1`**, while keeping all other bits the same.

### The Strategy
Since `nums[i]` is the result of `x | (x + 1)`, `nums[i]` essentially represents `x` but with its rightmost `0` turned into a `1`.
To find the **minimum** `x` (original number):
1.  We examine `nums[i]`. Since `nums[i]` is prime (and thus odd, except for 2), its binary representation ends with a sequence of `1`s.
2.  We scan from the Least Significant Bit (LSB) towards the left to find the **first zero bit** at index `j`.
3.  The bit immediately to the right of this zero (at index `j-1`) must have been the one that was flipped to generate the sequence of `1`s.
4.  To recover `x`, we simply **flip the bit at `j-1` back to `0`**. This minimizes `x` because we are removing the most significant bit possible within that consecutive block of changes.

### Special Case
* If `nums[i] == 2` (Binary `10`): The first `0` is at index 0. There is no bit at index `-1` to flip. Thus, it's impossible. Return `-1`.

---

## üíª Solution Code

### 1Ô∏è‚É£ Brute Force Approach (C++)

This approach checks every possible number up to `nums[i]` to see if it satisfies the condition. While correct, it is inefficient for large constraints.

```cpp
// Intuition: Iterate through all possible values of x starting from 0. The first x satisfying x | (x+1) == num is the minimum.
// Approach: For each number in nums, loop x from 0 to num-1. Check bitwise condition. If found, add to result and break.
// Time Complexity: O(N * M) where N is array length and M is the maximum value in nums (can be up to 10^9, causing TLE).
// Space Complexity: O(1) ignoring result storage.

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;

        for(int &num : nums) {

            bool found = false;
            // Try every possible x from 0 up to num
            for(int x = 0; x < num; x++) {
                // Check the condition given in the problem
                if((x | (x+1)) == num) {
                    result.push_back(x);
                    found = true;
                    break; // Since we want minimum, break on first find
                }
            }
            // If no x works, append -1
            if(!found)
                result.push_back(-1);

        }

        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [2, 3]
* 1. num = 2: Loop x=0, 0|1=1!=2. x=1, 1|2=3!=2. No x found. Push -1.
* 2. num = 3: Loop x=0, 0|1=1!=3. x=1, 1|2=3==3. Match! Push 1.
* Result: [-1, 1]
*
*/
```

### 2Ô∏è‚É£ Optimized Approach (C++)

This approach uses bit manipulation to find the answer directly in constant time per element (checking 32 bits).

```cpp
// Intuition: x | (x+1) sets the rightmost 0-bit of x to 1. To retrieve x from nums[i], find the first 0-bit in nums[i] and unset the bit immediately to its right.
// Approach: Iterate bits of nums[i] from LSB. Find first '0' at index j. Result is nums[i] with bit (j-1) flipped to 0. Handle '2' as edge case.
// Time Complexity: O(N) because the inner loop runs max 32 times (constant).
// Space Complexity: O(1) ignoring result storage.

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result;

        for(int i = 0; i < n; i++) {
            // Edge case: 2 is the only even prime, logic fails as first 0 is at bit 0
            if(nums[i] == 2) {
                result.push_back(-1);
                continue;
            }

            bool found = false;
            // Iterate from 2nd bit (index 1) since primes > 2 are odd (bit 0 is always 1)
            for(int j = 1; j < 32; j++) {
                // If bit j is 1, continue searching for a 0
                if((nums[i] & (1 << j)) > 0) {
                    continue;
                }

                // Found the first 0 at bit j.
                // The bit to unset to get minimum x is at j-1.
                int x = (nums[i] ^ (1 << (j - 1)));
                result.push_back(x);
                found = true;
                break;
            }
            
            // Should theoretically effectively not reach here for prime > 2 inputs
            if(found == false) {
                result.push_back(-1);
            }
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [7] (Binary: ...00111)
* 1. i=0, nums[0]=7. Not 2.
* 2. Inner loop j=1: (7 & 2) > 0? Yes (bit 1 is 1). Continue.
* 3. Inner loop j=2: (7 & 4) > 0? Yes (bit 2 is 1). Continue.
* 4. Inner loop j=3: (7 & 8) > 0? No (bit 3 is 0). Found first zero!
* 5. Calculate x: Flip bit (3-1)=2. 
* x = 7 ^ (1<<2) = 0111 ^ 0100 = 0011 (Decimal 3).
* 6. Push 3. Found = true. Break.
* Result: [3]
*
*/
```

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/description/) for original content and copyright.**