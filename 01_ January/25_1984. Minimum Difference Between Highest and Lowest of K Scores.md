# 1984. Minimum Difference Between Highest and Lowest of K Scores

<p align="center">
  <a href="https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">
    <img src="https://img.shields.io/badge/LeetCode-1984-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode Problem" />
  </a>
  <br />
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=flat-square" alt="Difficulty" />
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=flat-square&logo=c%2B%2B&logoColor=white" alt="Language" />
</p>

## ğŸ“‹ Problem Statement

You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.

Pick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.

Return *the **minimum** possible difference*.

---

## ğŸ” Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `nums = [90], k = 1` | `0` | There is one way to pick score(s) of one student: `[90]`. Difference is `90 - 90 = 0`. |
| **2** | `nums = [9,4,1,7], k = 2` | `2` | Picking `[9, 7]` gives diff `9-7=2`. Other combinations like `[9,4]` give larger differences. |

---

## ğŸ›‘ Constraints

- `1 <= k <= nums.length <= 1000`
- `0 <= nums[i] <= 10^5`

---

## ğŸ’¡ Approach

### Key Idea: Sorting
The problem asks us to select `k` numbers such that the difference between the maximum and minimum of these selected numbers is as small as possible.

If we select `k` numbers from an unsorted array, the values might be far apart (e.g., picking 1 and 100 from `[1, 50, 100]`). However, if we **sort** the array first, the numerically closest numbers will be adjacent to each other.

### Logic
1.  **Sort the array**: This groups close values together.
2.  **Sliding Window**: Once sorted, any contiguous subarray of size `k` represents a selection of `k` students with relatively close scores.
3.  For any contiguous window ending at index `j` and starting at index `i`, the largest value is `nums[j]` and the smallest is `nums[i]` (because the array is sorted).
4.  The difference for this window is `nums[j] - nums[i]`.
5.  We iterate through all possible windows of size `k`, calculate the difference, and track the minimum one.

---

## ğŸ’» Solution Code

### 1ï¸âƒ£ Sliding Window (Two Pointers) Implementation

```cpp
// Intuition: After sorting, the k closest scores will form a contiguous segment. We use a sliding window of size k to check all such segments.
// Approach: Sort the array. Initialize pointers i (start) and j (end) for the first window of size k. Slide both by 1 until j reaches the end.
// Time Complexity: O(N log N) due to sorting, where N is the size of nums. The loop runs in O(N).
// Space Complexity: O(1) or O(log N) depending on the internal sort implementation (ignoring input storage).

class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        int n = nums.size();
        
        // Handle edge case where only 1 student is picked
        if (k == 1) return 0;

        // Initialize minDiff to maximum possible integer
        int minDiff = INT_MAX;
        
        // Sort to group closest values together
        sort(begin(nums), end(nums));

        int i = 0;      // Start of window
        int j = k - 1;  // End of window (size k)

        // Slide the window across the array
        while(j < n) {
            int minEl = nums[i]; // Smallest in current window
            int maxEl = nums[j]; // Largest in current window

            // Update minimum difference found so far
            minDiff = min(minDiff, maxEl - minEl);
            
            // Move window forward
            i++;
            j++;
        }
        return minDiff;
    }
};

/*
*
* Dry Run
* Input: nums = [9, 4, 1, 7], k = 2
* Sorted nums: [1, 4, 7, 9], n = 4
*
* Initialization:
* minDiff = INT_MAX
* i = 0, j = 1 (Since k=2, window is indices 0 to 1)
*
* Iteration 1:
* j = 1 (< 4)
* minEl = nums[0] = 1
* maxEl = nums[1] = 4
* diff = 4 - 1 = 3
* minDiff = min(INT_MAX, 3) = 3
* i becomes 1, j becomes 2
*
* Iteration 2:
* j = 2 (< 4)
* minEl = nums[1] = 4
* maxEl = nums[2] = 7
* diff = 7 - 4 = 3
* minDiff = min(3, 3) = 3
* i becomes 2, j becomes 3
*
* Iteration 3:
* j = 3 (< 4)
* minEl = nums[2] = 7
* maxEl = nums[3] = 9
* diff = 9 - 7 = 2
* minDiff = min(3, 2) = 2
* i becomes 3, j becomes 4
*
* Loop terminates (j is 4).
* Return 2.
*/

```

### 2ï¸âƒ£ Optimized For Loop Implementation

```cpp
// Intuition: Same as above, but implemented more concisely using a single loop variable for the window's end.
// Approach: Sort the array. Iterate from index k-1 to n-1. The current index i is the max element, and i-k+1 is the min element of the current window.
// Time Complexity: O(N log N) primarily due to the sorting step.
// Space Complexity: O(1) assuming disjoint sorting or O(log N) stack space for sorting.

class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        int n = nums.size();
        
        // Edge case: selecting 1 score results in 0 difference
        if (n == 0 || k == 1) return 0; 

        // Sorting is crucial to minimize the range
        sort(begin(nums), end(nums));
        
        int minDiff = INT_MAX;

        // Iterate starting from the end of the first valid window
        for(int i = k - 1; i < n; i++) {
            // In a sorted window of size k ending at i:
            // Max is at index i
            // Min is at index i - k + 1
            int minEl = nums[i - k + 1];
            int maxEl = nums[i];

            // Update the global minimum difference
            minDiff = min(minDiff, maxEl - minEl);
        }
        return minDiff;
    }
};

/*
*
* Dry Run
* Input: nums = [9, 4, 1, 7], k = 2
* Sorted: [1, 4, 7, 9]
*
* Loop starts at i = k - 1 = 1
*
* i = 1:
* maxEl = nums[1] = 4
* minEl = nums[1 - 2 + 1] = nums[0] = 1
* minDiff = min(INT_MAX, 4 - 1) = 3
*
* i = 2:
* maxEl = nums[2] = 7
* minEl = nums[2 - 2 + 1] = nums[1] = 4
* minDiff = min(3, 7 - 4) = 3
*
* i = 3:
* maxEl = nums[3] = 9
* minEl = nums[3 - 2 + 1] = nums[2] = 7
* minDiff = min(3, 9 - 7) = 2
*
* Loop ends. Return 2.
*/

```

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)
