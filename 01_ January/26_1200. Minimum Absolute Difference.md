# 1200. Minimum Absolute Difference

<p align="center">
  <a href="https://leetcode.com/problems/minimum-absolute-difference/">
    <img src="https://img.shields.io/badge/LeetCode-1200-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 1200">
  </a>
  <a href="https://leetcode.com/problems/minimum-absolute-difference/">
    <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Easy">
  </a>
</p>

## ğŸ“Œ Problem Statement

Given an array of **distinct** integers `arr`, find all pairs of elements with the minimum absolute difference of any two elements.

Return a list of pairs in ascending order(with respect to pairs), each pair `[a, b]` follows:
* `a`, `b` are from `arr`
* `a < b`
* `b - a` equals to the minimum absolute difference of any two elements in `arr`

## ğŸ“Š Constraints

* `2 <= arr.length <= 10^5`
* `-10^6 <= arr[i] <= 10^6`

## ğŸ§© Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `arr = [4,2,1,3]` | `[[1,2],[2,3],[3,4]]` | The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. |
| **2** | `arr = [1,3,6,10,15]` | `[[1,3]]` | The minimum absolute difference is 2 (between 1 and 3). |
| **3** | `arr = [3,8,-10,23,19,-4,-14,27]` | `[[-14,-10],[19,23],[23,27]]` | The minimum absolute difference is 4. |

## ğŸ’¡ Approach

The core idea is that in a sorted array, the minimum absolute difference between any two elements must occur between adjacent elements.

1.  **Sort the Array**: First, sort the given array `arr` in ascending order. This places the closest elements next to each other.
2.  **Find Minimum Difference**: Iterate through the sorted array once to calculate the difference between every adjacent pair (`arr[i] - arr[i-1]`) and track the smallest difference found (`minDiff`).
3.  **Collect Pairs**: Iterate through the array a second time. Whenever the difference between `arr[i]` and `arr[i-1]` equals the `minDiff`, add the pair `{arr[i-1], arr[i]}` to the result list.

This approach ensures efficient discovery of the minimum difference and collects all matching pairs in the required sorted order.

## ğŸš€ Solution Code

```cpp
// Intuition: Sorting the array ensures that the smallest difference between any two elements will be found between adjacent elements.
// Approach:
// 1. Sort the array to order elements.
// 2. Perform a pass to find the global minimum difference between adjacent elements.
// 3. Perform a second pass to collect all adjacent pairs that match this minimum difference.
// Time Complexity: O(N log N) due to the sorting step.
// Space Complexity: O(1) ignoring the space required for the output vector (or O(log N) for internal sort stack).

class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        int n = arr.size();
        sort(begin(arr), end(arr)); // Sort to align closest elements

        int minDiff = INT_MAX;

        // Pass 1: Find the minimum absolute difference
        for(int i = 1; i < n; i++) {
            minDiff = min(minDiff, arr[i] - arr[i - 1]);
        }

        vector<vector<int>> result;
        // Pass 2: Collect all pairs matching minDiff
        for(int i = 1; i < n; i++) {
            int diff = arr[i] - arr[i - 1];

            if(diff == minDiff) {
                result.push_back({arr[i - 1], arr[i]});
            }
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: arr = [4, 2, 1, 3]
*
* 1. Sort array:
* arr becomes [1, 2, 3, 4]
*
* 2. First Loop (Find minDiff):
* i = 1: diff = 2 - 1 = 1 -> minDiff = 1
* i = 2: diff = 3 - 2 = 1 -> minDiff = 1
* i = 3: diff = 4 - 3 = 1 -> minDiff = 1
* Final minDiff = 1
*
* 3. Second Loop (Collect pairs):
* i = 1: diff (1) == minDiff (1) -> push {1, 2}
* i = 2: diff (1) == minDiff (1) -> push {2, 3}
* i = 3: diff (1) == minDiff (1) -> push {3, 4}
*
* Output: [[1, 2], [2, 3], [3, 4]]
*/

```

## ğŸ¯ Key Insights

* **Sorting simplifies the problem**: Without sorting, finding the minimum difference would require comparing every pair, leading to  complexity. Sorting reduces the search space to just adjacent pairs.
* **Two-pass vs. One-pass**: While it's possible to solve this in a single pass (by clearing the result vector if a new smaller difference is found), a two-pass approach is often cleaner and easier to read.
* **Ascending Order**: Since the array is sorted initially, collecting pairs sequentially automatically satisfies the requirement to return pairs in ascending order.

## ğŸ·ï¸ Tags

`Array` `Sorting` `C++`

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-absolute-difference/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)