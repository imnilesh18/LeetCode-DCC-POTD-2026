# 744. Find Smallest Letter Greater Than Target

<p align="center">
  <a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/">
    <img src="https://img.shields.io/badge/LeetCode-744-orange?style=for-the-badge&logo=leetcode" alt="LeetCode">
  </a>
  <a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/">
    <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Easy">
  </a>
</p>

## ğŸ“ Problem Statement

You are given an array of characters `letters` that is sorted in **non-decreasing order**, and a character `target`. There are **at least two different** characters in `letters`.

Return *the smallest character in `letters` that is lexicographically greater than `target`*. If such a character does not exist, return the first character in `letters`.

## ğŸ”’ Constraints

- `2 <= letters.length <= 10^4`
- `letters[i]` is a lowercase English letter.
- `letters` is sorted in **non-decreasing** order.
- `letters` contains at least two different characters.
- `target` is a lowercase English letter.

## ğŸ“Š Examples

**Example 1:**

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `letters = ["c","f","j"], target = "a"` | `"c"` | The smallest character that is lexicographically greater than 'a' in letters is 'c'. |

**Example 2:**

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `letters = ["c","f","j"], target = "c"` | `"f"` | The smallest character that is lexicographically greater than 'c' in letters is 'f'. |

**Example 3:**

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `letters = ["x","x","y","y"], target = "z"` | `"x"` | There are no characters in letters that is lexicographically greater than 'z' so we return letters[0]. |

## ğŸ’¡ Approach

The problem asks for the smallest character strictly greater than the `target`. Since the array `letters` is already **sorted in non-decreasing order**, we can utilize efficient search algorithms.

### 1. Brute Force (Linear Scan)
We can iterate through the array from left to right. The first character we encounter that is strictly greater than `target` is our answer. If we reach the end of the array without finding one, due to the circular nature of the problem (wrap around), the answer is the first element `letters[0]`.
* **Time Complexity:** $O(N)$
* **Space Complexity:** $O(1)$

### 2. Binary Search (Optimal)
Since the array is sorted, **Binary Search** is the most efficient approach. We need to find the "upper bound" of the target.
* We maintain a search space `[l, r]`.
* If `letters[mid] > target`: This `mid` is a potential candidate. We store it and attempt to find a smaller valid character to its left (`r = mid - 1`).
* If `letters[mid] <= target`: The character at `mid` (and everything to its left) is not greater than the target. We search the right half (`l = mid + 1`).
* If no valid character is found after the loop, return `letters[0]`.

### 3. STL `upper_bound`
C++ provides a built-in function `std::upper_bound` which performs binary search to find the first element strictly greater than a value. We can use this directly for a concise solution.

## ğŸ’» Solution Code

### Approach 1: Custom Binary Search

```cpp
// Intuition: Since the array is sorted, we can utilize Binary Search to find the smallest element strictly greater than the target in logarithmic time.
// Approach: 
// 1. Use standard Binary Search with left (l) and right (r) pointers.
// 2. If mid element > target, it's a candidate; record it and move left to find a smaller valid one.
// 3. If mid element <= target, move right.
// 4. Handle the wrap-around case if no element is found.
// Time Complexity: O(log n) - standard binary search complexity.
// Space Complexity: O(1) - only constant extra space used.

class Solution {
public:
    
    int binarySearch(vector<char>& letters, char target) {
        int n = letters.size();
        int l = 0, r = n-1;
        
        int position = n; // Initialize with n (indicates not found)
        
        while(l <= r) {
            
            int mid = l + (r-l)/2; // Calculate mid avoiding overflow
            
            if(letters[mid] > target) {
                position = mid; // Found a valid character, try finding a smaller one on left
                r = mid-1;
            } else {
                l = mid+1;      // Current is too small/equal, move right
            }
            
        }
        
        return position;
    }
    
    char nextGreatestLetter(vector<char>& letters, char target) {
        
        int idx = binarySearch(letters, target); // Perform BS
        
        if(idx == letters.size()) // If no element > target found
            return letters[0];    // Wrap around to start
        
        return letters[idx];      // Return the found character
        
    }
};

/*
*
* Dry Run
* Input: letters = ["c", "f", "j"], target = "a"
* Initial: n = 3, l = 0, r = 2, position = 3
*
* Iteration 1:
* mid = 0 + (2-0)/2 = 1. letters[1] is 'f'.
* 'f' > 'a' -> True. 
* position = 1.
* r becomes 0.
*
* Iteration 2:
* l = 0, r = 0.
* mid = 0 + (0-0)/2 = 0. letters[0] is 'c'.
* 'c' > 'a' -> True.
* position = 0.
* r becomes -1.
*
* Loop Ends (l > r).
* Result index is 0.
* Return letters[0] which is 'c'.
*
*/

```

### Approach 2: Using C++ STL `upper_bound`

```cpp
// Intuition: The problem requires finding the first element strictly strictly greater than target in a sorted container, which matches the behavior of std::upper_bound.
// Approach: Use std::upper_bound to locate the iterator. If it points to end(), wrap around to the first element; otherwise return the pointed element.
// Time Complexity: O(log n) - upper_bound uses binary search internally.
// Space Complexity: O(1) - no extra memory allocated.

class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        // Find iterator to first element strictly > target
        int idx = upper_bound(begin(letters), end(letters), target) - begin(letters);
        
        if(idx == letters.size()) // If iterator reached end (not found)
            return letters[0];    // Return first element (wrap around)
        
        return letters[idx];      // Return the found element
    }
};

/*
*
* Dry Run
* Input: letters = ["c", "f", "j"], target = "j"
*
* upper_bound search:
* Looks for first element > 'j'.
* 'c' <= 'j', 'f' <= 'j', 'j' <= 'j'.
* Iterator reaches end().
*
* idx calculation:
* idx = end() - begin() = 3.
*
* Check:
* idx (3) == letters.size() (3).
* Return letters[0] -> "c".
*
*/

```

## ğŸ” Key Insights

1. **Sorted Input:** The input `letters` is sorted in non-decreasing order. This is a huge hint to use **Binary Search**.
2. **Circular Property:** The problem states "If such a character does not exist, return the first character". This means our search space effectively wraps around. In code, this translates to checking if our finding index is out of bounds (equals array size) and returning index 0 instead.
3. **Upper Bound:** The logic strictly follows the mathematical definition of an upper bound (smallest value strictly greater than ).

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-smallest-letter-greater-than-target/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)