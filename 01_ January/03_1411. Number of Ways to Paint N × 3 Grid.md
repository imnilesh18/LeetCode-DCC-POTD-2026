# 1411. Number of Ways to Paint N √ó 3 Grid

<p align="center">
  <a href="https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/">
    <img src="https://img.shields.io/badge/LeetCode-1411-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 1411">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github" alt="Author">
  </a>
  <a href="#license">
    <img src="https://img.shields.io/badge/License-MIT-green?style=for-the-badge" alt="License">
  </a>
</p>

## üìù Problem Statement

You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow**, or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given `n` the number of rows of the grid, return *the number of ways* you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `10^9 + 7`.

---

## üì∏ Examples

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2020/03/26/e1.png" alt="Example 1 Image" width="400"/>
</div>

| Example | Input | Output | Explanation |
| :---: | :---: | :---: | :--- |
| **1** | `n = 1` | `12` | There are 12 possible ways to paint the grid as shown in the image. |
| **2** | `n = 5000` | `30228214` | The result is computed modulo 10^9 + 7. |

---

## üîç Constraints

- `n == grid.length`
- `1 <= n <= 5000`

---

## üí° Approach & Key Insights

The problem asks us to find the number of valid colorings for an `n x 3` grid using 3 colors such that no adjacent cells (horizontal or vertical) share the same color.

### 1. Precomputing Valid States
Since the grid has a fixed width of 3 columns, we can precalculate all valid color configurations for a single row.
- For the first cell, we have **3** color choices.
- For the second cell, we have **2** choices (different from the first).
- For the third cell, we have **2** choices (different from the second).
- Total valid patterns for a single row = $3 \times 2 \times 2 = 12$.
- These patterns are stored in a `states` array (e.g., "RYG", "RGY", etc.).

### 2. Recursion with Memoization (DP)
We can build the grid row by row. The validity of the current row depends **only** on the configuration of the immediately preceding row.
- **State**: `solve(n, prev)` where `n` is the number of rows left to paint, and `prev` is the index (0-11) of the pattern used in the previous row.
- **Transitions**: For the current row, try all 12 patterns. A pattern is valid if it doesn't conflict with the `prev` pattern (i.e., `currPat[col] != last[col]` for all columns).
- **Base Case**: If `n == 0`, we have successfully painted all rows, so return 1.
- **Memoization**: Store results in a table `t[n][prev]` to avoid recomputing states.

### 3. Complexity Analysis
- Since `n` is up to 5000 and there are only 12 states, the DP approach is highly efficient. The transitions involve a constant loop of size 12.

---

## üíª Solution Code

```cpp
// Intuition: The problem can be broken down row by row. Since the width is fixed at 3, there are only 12 valid ways to paint a single row. The state of a row only depends on the previous row's pattern to satisfy vertical adjacency constraints.
// Approach: Use Dynamic Programming (Recursion + Memoization). Precompute the 12 valid single-row patterns. Define a recursive function that tries to paint the current row with one of the 12 patterns, checking for vertical conflicts with the previous row.
// Time Complexity: O(N) - There are N rows and 12 states for previous row. The transition takes constant time (12 * 3 iterations). Total states = N * 12.
// Space Complexity: O(N) - Used for the recursion stack and the memoization table of size N * 12.

class Solution {
public:
    int M = 1e9 + 7;
    vector<vector<int>> t;
    // 12 possible first rows
    string states[12] = {"RYG", "RGY", "RYR", "RGR", "YRG", "YGR", "YGY", "YRY", "GRY", "GYR", "GRG", "GYG"};

    int solve(int n, int prev) {
        // Base case: If no rows remaining, we found 1 valid way
        if(n == 0) {
            return 1;
        }

        // Return memoized result if available
        if(t[n][prev] != -1) {
            return t[n][prev];
        }

        int result = 0;
        string last = states[prev];
        
        // Try all 12 possible patterns for the current row
        for(int curr = 0; curr < 12; curr++) {
            // Optimization: Skip if pattern indices are same (optional, logic handled by conflict check)
            if(curr == prev) {
                continue;
            }

            string currPat = states[curr];
            bool conflict = false;
            
            // Check for vertical conflicts with the previous row
            for(int col = 0; col < 3; col++) {
                if(currPat[col] == last[col]) {
                    conflict = true;
                    break;
                }
            }

            // If no vertical conflict, proceed to the next row
            if(!conflict) {
                result = (result + solve(n - 1, curr)) % M;
            }
        }

        // Memoize and return
        return t[n][prev] = result;
    }

    int numOfWays(int n) {
        // Initialize memoization table with -1
        t.resize(n, vector<int>(12, -1));  //T.C : O(n)
        int result = 0;

        // Try painting the first row with each of the 12 possible patterns
        for(int i = 0; i < 12; i++) { // choosing 1st row
            // now remainig n - 1 rows painting 
            result = (result + solve(n - 1, i)) % M;
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: n = 1
* 1. numOfWays(1) called.
* 2. Loop i from 0 to 11 (representing 12 patterns like RYG, RGY...).
* 3. For i=0 ("RYG"):
* - Call solve(0, 0).
* - solve(0, 0) -> n is 0, returns 1.
* - result += 1.
* 4. This repeats for all 12 starting patterns.
* 5. Since n=1 implies we just paint one row, and there are no previous constraints, 
* all 12 patterns return 1.
* 6. Final Result = 12.
*
*/
```

---

## üîó References

- [LeetCode Problem 1411](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/)
- Related Problem: [LeetCode 1931. Painting a Grid With Three Different Colors](https://leetcode.com/problems/painting-a-grid-with-three-different-colors/)

---

## üè∑Ô∏è Tags

`Dynamic Programming` `Recursion` `Memoization` `Grid`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)