# 3507. Minimum Pair Removal to Sort Array I

<div align="center">

<img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge&logo=leetcode" alt="Easy" />
<img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="C++" />

</div>

---

## ğŸ”— Problem Link

[LeetCode Problem - Minimum Pair Removal to Sort Array I](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/)

---

## ğŸ“ Problem Statement

Given an array `nums`, you can perform the following operation any number of times:

1.  Select the **adjacent** pair with the **minimum** sum in `nums`. If multiple such pairs exist, choose the leftmost one.
2.  Replace the pair with their sum.

Return the **minimum number of operations** needed to make the array **non-decreasing**.

An array is said to be **non-decreasing** if each element is greater than or equal to its previous element (if it exists).

---

## ğŸ”’ Constraints

- `1 <= nums.length <= 50`
- `-1000 <= nums[i] <= 1000`

---

## ğŸ§ª Examples

### Example 1

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [5,2,3,1]` | `2` | 1. Pair `(3,1)` has min sum 4. `nums` becomes `[5,2,4]`.<br>2. Pair `(2,4)` has min sum 6. `nums` becomes `[5,6]`.<br>Array is now non-decreasing. |

### Example 2

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [1,2,2]` | `0` | The array is already sorted. |

---

## ğŸ’¡ Approach

The problem constraints (`N <= 50`) are small enough to allow for a direct simulation of the process described. We do not need a complex algorithm; we can simply follow the rules step-by-step.

1.  **Check Condition**: Continuously check if the array is already sorted (non-decreasing). If it is, we stop.
2.  **Find Minimum Pair**: If the array is not sorted, iterate through the array to find the adjacent pair `(nums[i], nums[i+1])` that has the minimum sum. If there are ties, the loop order naturally selects the leftmost one.
3.  **Perform Operation**:
    * Update the element at the found index `i` to be the sum of the pair.
    * Remove the element at index `i+1` from the array.
4.  **Count Operations**: Increment a counter for each operation performed.
5.  **Repeat**: Go back to step 1.

This brute-force simulation works efficiently because the array size reduces by 1 in each operation, and finding the minimum pair takes linear time relative to the current size.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Since the constraints are small (N <= 50), we can simulate the operations directly. We repeatedly merge the smallest adjacent pair until the array is sorted.
// Approach: Use a loop to check if sorted. Inside, find the min sum adjacent pair, merge them, erase the second element, and increment ops count.
// Time Complexity: O(N^2) roughly. is_sorted is O(N), finding min pair is O(N), erase is O(N). Loop runs at most N times.
// Space Complexity: O(1) auxiliary space, operating directly on the input vector.

class Solution {
public:
    // Helper function to find the index of the leftmost adjacent pair with minimum sum
    int minPairSum(vector<int>& nums) {
        int n = nums.size();
        int minSum = INT_MAX;
        int index = -1;

        // Iterate through adjacent pairs
        for(int i = 0; i < n - 1; i++) {
            // Check if current pair sum is strictly less than current min
            if(nums[i] + nums[i + 1] < minSum) {
                index = i;
                minSum = nums[i] + nums[i + 1];
            }
        }

        return index; // Return the starting index of the min pair
    }

    int minimumPairRemoval(vector<int>& nums) {
        int operations = 0;

        // Continue operations until array is sorted
        while(!is_sorted(begin(nums), end(nums))) {
            // Find index of pair to merge
            int index = minPairSum(nums);
            
            // Replace the first element of pair with the sum
            nums[index] = nums[index] + nums[index + 1];

            // Remove the second element of the pair
            nums.erase(begin(nums) + index + 1);
            
            operations++; // Increment operation count
        }
        return operations;
    }
};

/*
*
* Dry Run
* Input: nums = [5, 2, 3, 1]
* * Iteration 1:
* is_sorted([5, 2, 3, 1]) -> False
* Find min pair:
* (5,2)=7, (2,3)=5, (3,1)=4
* Min sum is 4 at index 2 (pair 3,1)
* Update: nums[2] = 3+1 = 4 -> [5, 2, 4, 1]
* Erase: nums[3] (1) -> [5, 2, 4]
* operations = 1
*
* Iteration 2:
* is_sorted([5, 2, 4]) -> False
* Find min pair:
* (5,2)=7, (2,4)=6
* Min sum is 6 at index 1 (pair 2,4)
* Update: nums[1] = 2+4 = 6 -> [5, 6, 4]
* Erase: nums[2] (4) -> [5, 6]
* operations = 2
*
* Iteration 3:
* is_sorted([5, 6]) -> True
* Loop terminates.
*
* Return 2
*/

```

---

## ğŸ”‘ Key Insights

* **Simulation works best:** Due to strict constraints on array size (), complex data structures are unnecessary.  or  solutions pass comfortably.
* **Vector Erase:** In C++, `vector::erase` is an  operation. Combined with finding the minimum pair () and repeating max  times, the logic holds up.
* **Leftmost Priority:** The problem specifically asks to pick the **leftmost** pair in case of a tie. Iterating from index `0` to `n-2` and only updating when a strictly smaller sum is found (`< minSum`) inherently handles this requirement perfectly (though `<=` would also work if we didn't update on equality, strict `<` ensures we keep the first found minimum).

---

## ğŸš€ Further Exploration

* How would the approach change if  were up to ? A simulation using `std::vector` would TLE.
* Could we use a priority queue or a linked list to optimize the "find minimum" and "deletion" steps for larger constraints?

---

## ğŸ·ï¸ Tags

* `Array`
* `Simulation`
* `Sorting`
* `Greedy`

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)
