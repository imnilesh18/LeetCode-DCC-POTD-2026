# 865. Smallest Subtree with all the Deepest Nodes

<p align="center">
  <a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">
    <img src="https://img.shields.io/badge/LeetCode-865-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 865" />
  </a>
  <a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">
    <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Difficulty Medium" />
  </a>
  <a href="https://leetcode.com/tag/tree/">
    <img src="https://img.shields.io/badge/Tag-Tree-green?style=for-the-badge" alt="Tag Tree" />
  </a>
  <a href="https://leetcode.com/tag/depth-first-search/">
    <img src="https://img.shields.io/badge/Tag-DFS-blue?style=for-the-badge" alt="Tag DFS" />
  </a>
  <a href="https://leetcode.com/tag/breadth-first-search/">
    <img src="https://img.shields.io/badge/Tag-BFS-purple?style=for-the-badge" alt="Tag BFS" />
  </a>
  <a href="https://leetcode.com/tag/hash-table/">
    <img src="https://img.shields.io/badge/Tag-Hash%20Table-red?style=for-the-badge" alt="Tag Hash Table" />
  </a>
</p>

## üìö Problem Statement

Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.

Return *the smallest subtree* such that it contains **all the deepest nodes** in the original tree.

A node is called **the deepest** if it has the largest depth possible among any node in the entire tree.

The **subtree** of a node is a tree consisting of that node, plus the set of all descendants of that node.

> **Note:** This question is the same as 1123: [Lowest Common Ancestor of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/)

---

## üìù Constraints

- The number of nodes in the tree will be in the range `[1, 500]`.
- `0 <= Node.val <= 500`
- The values of the nodes in the tree are **unique**.

---

## üîç Examples

### Example 1
**Input:** `root = [3,5,1,6,2,0,8,null,null,7,4]`  
**Output:** `[2,7,4]`  
**Explanation:** - The nodes colored in blue are the deepest nodes of the tree (nodes 7 and 4).
- We return the node with value 2, colored in yellow in the diagram.
- Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.

### Example 2
**Input:** `root = [1]`  
**Output:** `[1]`  
**Explanation:** The root is the deepest node in the tree.

### Example 3
**Input:** `root = [0,1,3,null,2]`  
**Output:** `[2]`  
**Explanation:** The deepest node in the tree is 2. The valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.

---

## üí° Approach 1: Two Pass Solution (Depth Map + LCA)

### Intuition
The problem asks for the smallest subtree containing all deepest nodes. This is equivalent to finding the **Lowest Common Ancestor (LCA)** of all nodes that have the maximum depth.
1. First, we need to know the depth of every node to identify which ones are the deepest.
2. Second, we find the LCA of these deepest nodes.

### Strategy
1. **Pass 1 (Calculate Depths):** Traverse the tree (DFS) to determine the depth of each node and store it in a map. Keep track of the global `maxD` (maximum depth).
2. **Pass 2 (Find LCA):** Traverse the tree again to find the LCA.
   - If a node is `null`, return `null`.
   - If the current node itself has the maximum depth (`maxD`), return it.
   - Recursively search left and right.
   - If both left and right calls return a non-null node, it means the current node is the LCA (it has deepest nodes in both branches).
   - Otherwise, return the non-null child.

### üíª Code

```cpp
// Intuition: Identify all nodes at maximum depth first, then find their Lowest Common Ancestor (LCA).
// Approach: 
// 1. Perform a DFS to calculate depth of all nodes, store in map, and find max depth.
// 2. Perform another traversal (LCA logic) to find the common ancestor of nodes with max depth.
// Time Complexity: O(N) - Two passes over the tree (one for depth, one for LCA).
// Space Complexity: O(N) - For the hash map and recursion stack.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 
//Approach-1 (Using 2 Pass Solution and LCA code)
//T.C : O(2*n) ~= O(n)
//S.C : O(maxDepth) System stack space + O(n) Map space
class Solution {
public:
    unordered_map<int, int> mp; // Stores depth of each node
    int maxD = 0;               // Tracks the maximum depth found

    TreeNode* LCA(TreeNode* root) {
        // Base case: empty node or node is one of the deepest nodes
        if(root == NULL || mp[root->val] == maxD) {
            return root;
        }

        TreeNode* l = LCA(root->left);  // Search left
        TreeNode* r = LCA(root->right); // Search right

        // If deepest nodes found in both subtrees, current is LCA
        if(l && r) {
            return root;
        }

        // Return the non-null child (propagating the deepest node up)
        return l != NULL ? l : r;
    }

    void depth(TreeNode* root, int d) {
        if(!root) {
            return;
        }

        maxD = max(maxD, d);        // Update global max depth
        mp[root->val] = d;          // Map node value to its depth
        depth(root->left, d+1);     // Recurse left
        depth(root->right, d+1);    // Recurse right
    }
    
    // Main function
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        depth(root, 0); // Pass 1: Populate depths
        return LCA(root); // Pass 2: Find LCA
    }
};

/*
*
* Dry Run: Example 1: root = [3,5,1,6,2,0,8,null,null,7,4]
* 1. depth() runs:
* - maxD becomes 3.
* - mp: {3:0, 5:1, 1:1, 6:2, 2:2, 0:2, 8:2, 7:3, 4:3}
* 2. LCA(3) called:
* - Left: LCA(5)
* - Left: LCA(6) -> depth 2 != 3 -> Left(null), Right(null) -> returns null.
* - Right: LCA(2)
* - Left: LCA(7) -> depth 3 == 3 -> returns Node(7).
* - Right: LCA(4) -> depth 3 == 3 -> returns Node(4).
* - LCA(2) sees l=7, r=4 -> returns Node(2).
* - LCA(5) sees l=null, r=2 -> returns Node(2).
* - Right: LCA(1)
* - Left: LCA(0) -> depth 2 != 3 -> returns null.
* - Right: LCA(8) -> depth 2 != 3 -> returns null.
* - LCA(1) returns null.
* - LCA(3) sees l=2, r=null -> returns Node(2).
* Answer: [2,7,4]
*/
```

---

## üí° Approach 2: One Pass Solution (Bottom-Up DFS)

### Intuition
We can solve this in a single traversal. For any node, we need two pieces of information from its children:
1. The **depth** of the deepest node in that subtree.
2. The **LCA** of the deepest nodes in that subtree.

### Strategy
1. Use a helper function that returns a `pair<int, TreeNode*>` representing `{height, LCA}`.
2. **Recursive Step:**
   - If `root` is null, return `{0, NULL}`.
   - Recurse on left and right children to get their pairs (`l`, `r`).
   - `l.first` is the height of the left subtree, `r.first` is height of right.
3. **Comparing Heights:**
   - If `left height == right height`: The current `root` is the LCA of the deepest nodes found so far. The combined height is `left height + 1`. Return `{l.first + 1, root}`.
   - If `left height > right height`: The deepest nodes are strictly in the left subtree. The LCA stays whatever the left child returned (`l.second`). Return `{l.first + 1, l.second}`.
   - If `right height > left height`: The deepest nodes are strictly in the right subtree. The LCA stays whatever the right child returned (`r.second`). Return `{r.first + 1, r.second}`.

### üíª Code

```cpp
// Intuition: Compute height and LCA simultaneously bottom-up. If subtrees have equal height, current node is the new LCA.
// Approach: 
// 1. Recursive function returns pair {height, lca_node}.
// 2. If left height == right height, deepest nodes are split, so current node is LCA.
// 3. If heights differ, the deepest nodes (and their LCA) are in the taller subtree.
// Time Complexity: O(N) - Single pass over the tree.
// Space Complexity: O(H) - Recursion stack space (Height of tree).

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

//Approach-2 (Using 1 Pass Solution)
//T.C : O(n)
//S.C : O(maxDepth) System stack space
class Solution {
public:
    pair<int, TreeNode*> solve(TreeNode* root) {
        // Base case: Empty subtree has height 0 and no LCA
        if(root == NULL) {
            return {0, NULL};
        }

        // Recursive step: Get info from left and right children
        auto l = solve(root->left);
        auto r = solve(root->right);

        // Case 1: Both subtrees are equally deep
        // Current node is the common ancestor for deepest nodes on both sides
        if(l.first == r.first) {
            return {l.first+1, root};
        } 
        // Case 2: Left subtree is deeper
        // Deepest nodes are only on the left, so keep left's LCA
        else if(l.first > r.first) {
            return {l.first+1, l.second};
        } 
        // Case 3: Right subtree is deeper
        // Deepest nodes are only on the right, so keep right's LCA
        else {
            return {r.first+1, r.second};
        }
    }

    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        // Return the LCA node from the result pair
        return solve(root).second;   
    }
};

/*
*
* Dry Run: Example 3: root = [0,1,3,null,2]
* Structure:
* 0
* / \
* 1   3
* \
* 2
*
* 1. solve(0) calls solve(1) and solve(3).
* 2. solve(1):
* - Left: null -> {0, null}
* - Right: solve(2) -> {1, Node(2)} (leaf returns height 1, itself)
* - Right > Left (1 > 0) -> Returns {2, Node(2)}
* 3. solve(3):
* - Left: null -> {0, null}
* - Right: null -> {0, null}
* - Equal -> Returns {1, Node(3)}
* 4. Back at solve(0):
* - Left result: {2, Node(2)}
* - Right result: {1, Node(3)}
* - Left height (2) > Right height (1).
* - Return {3, Node(2)}.
* Result: Node 2.
*/
```

---

## üîë Key Insights

- **LCA Definition Extension:** The problem is a variation of LCA. Standard LCA finds the ancestor of two specific nodes. Here, we implicitly find the LCA of *all* nodes that share the global maximum depth.
- **Height vs. Depth:**
  - **Depth** is distance from root down to node.
  - **Height** is distance from node down to deepest leaf.
  - Approach 2 effectively uses height to determine where the deepest nodes lie relative to the current node.
- **Balancing Act:** If the "height" of the left child equals the "height" of the right child, the current node is the pivot point where the paths to the deepest nodes diverge; hence, it is the `Smallest Subtree`.

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)