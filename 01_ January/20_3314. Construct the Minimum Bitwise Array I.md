# 3314. Construct the Minimum Bitwise Array I

<div align="center">

<a href="https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/">
    <img src="https://img.shields.io/badge/LeetCode-3314-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode Problem">
</a>
<a href="https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/">
    <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Difficulty">
</a>

<br>
<a href="https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/">
    <img src="https://img.shields.io/badge/View%20Problem-blue?style=for-the-badge&logo=link" alt="View Problem">
</a>

</div>

---

## üìù Problem Statement

You are given an array `nums` consisting of `n` **prime** integers.

You need to construct an array `ans` of length `n`, such that, for each index `i`, the bitwise **OR** of `ans[i]` and `ans[i] + 1` is equal to `nums[i]`.

$$ans[i] \text{ OR } (ans[i] + 1) == nums[i]$$

Additionally, you must **minimize** each value of `ans[i]` in the resulting array.

If it is **not possible** to find such a value for `ans[i]` that satisfies the condition, then set `ans[i] = -1`.

---

## üîí Constraints

- `1 <= nums.length <= 100`
- `2 <= nums[i] <= 1000`
- `nums[i]` is a prime number.

---

## üß™ Examples

### Example 1

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [2,3,5,7]` | `[-1,1,4,3]` | **i = 0:** No `ans[0]` satisfies condition for `2`, so `-1`.<br>**i = 1:** Smallest `ans[1]` for `3` is `1` (`1 OR 2 = 3`).<br>**i = 2:** Smallest `ans[2]` for `5` is `4` (`4 OR 5 = 5`).<br>**i = 3:** Smallest `ans[3]` for `7` is `3` (`3 OR 4 = 7`). |

### Example 2

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [11,13,31]` | `[9,12,15]` | **i = 0:** Smallest `ans[0]` for `11` is `9` (`9 OR 10 = 11`).<br>**i = 1:** Smallest `ans[1]` for `13` is `12` (`12 OR 13 = 13`).<br>**i = 2:** Smallest `ans[2]` for `31` is `15` (`15 OR 16 = 31`). |

---

## üí° Approach

### 1. Brute Force (Valid for Small Constraints)
The simplest way to solve this is to iterate through every possible candidate number `x` starting from `0` up to `nums[i] - 1`.
- For each `x`, check if `(x | (x + 1)) == nums[i]`.
- The first `x` that satisfies this condition is our minimal answer.
- If the loop finishes without finding an answer, the result is `-1`.

### 2. Optimized Bit Manipulation (Observation)
By analyzing the operation `x | (x + 1)`, we observe a pattern:
- The operation `x + 1` flips all trailing `1`s of `x` to `0`s and flips the rightmost `0` to `1`.
- Performing `OR` with `x` effectively keeps all original bits of `x` but sets that rightmost `0` to `1`.
- **Key Insight:** `nums[i]` is essentially `x` with its first zero-bit (from the right) turned into a one.
- **Reverse Logic:** To find `x` from `nums[i]`, we iterate from the Least Significant Bit (LSB) upwards. The first time we encounter a `0` at position `j` in `nums[i]` (conceptually), it means the bit at `j-1` was the one flipped.
- Since `nums[i]` is prime, it is almost always odd (LSB is 1), except for `2`.
- **Algorithm:**
    1. Handle `nums[i] == 2` separately (return `-1`).
    2. Iterate bits starting from index 1.
    3. Find the first bit position `j` that is `0`.
    4. The answer `x` is obtained by flipping the bit at `j-1` in `nums[i]` to `0`.

---

## üíª Solution Code

### 1. Brute Force Approach

```cpp
// Intuition: Try all numbers from 0 to num-1 to see if they satisfy the condition x | (x+1) == num.
// Approach: Iterate x from 0. Check bitwise OR condition. Return first match (guaranteed minimum).
// Time Complexity: O(n * m), where n is array size and m is the maximum value in nums (1000).
// Space Complexity: O(1), ignoring result storage.

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;

        for(int &num : nums) {

            bool found = false;
            // Iterate through all possible values of x less than the target number
            for(int x = 0; x < num; x++) {
                // Check the core condition: x OR (x+1) should equal num
                if((x | (x+1)) == num) {
                    result.push_back(x); // Smallest x found
                    found = true;
                    break;
                }
            }
            // If no valid x is found, append -1
            if(!found)
                result.push_back(-1);

        }

        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [2, 3]
*
* Iteration 1: num = 2
* x = 0: (0 | 1) = 1 != 2
* x = 1: (1 | 2) = 3 != 2
* Loop ends. found = false.
* result = [-1]
*
* Iteration 2: num = 3
* x = 0: (0 | 1) = 1 != 3
* x = 1: (1 | 2) = 3 == 3 -> Match!
* found = true. Break.
* result = [-1, 1]
*
* Return [-1, 1]
*
*/

```

### 2. Optimized Approach (Bit Manipulation)

```cpp
// Intuition: x | (x+1) sets the rightmost 0 bit of x to 1. To reverse this, we find the first 0 bit in num and flip the bit before it to 0.
// Approach: Check special case 2. Scan bits from LSB. Find first 0 at index j. Flip bit (j-1) to 0.
// Time Complexity: O(n), inner loop runs max 31 times (constant).
// Space Complexity: O(1), ignoring result storage.

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result;

        for(int i = 0; i < n; i++) {
            // Case for prime number 2: No solution exists as 2 is even (binary 10)
            if(nums[i] == 2) {
                result.push_back(-1);
                continue;
            }

            bool found = false;
            // Iterate bits starting from the 2nd bit (index 1) since primes > 2 are odd (bit 0 is 1)
            for(int j = 1; j < 32; j++) {
                // Check if the j-th bit is set (1)
                if((nums[i] & (1 << j)) > 0) {
                    continue; // Skip consecutive 1s
                }

                // Found the first 0 at position j.
                // The bit to flip to recover x is at j-1.
                
                // XOR with (1 << (j-1)) toggles the (j-1)th bit from 1 to 0
                int x = (nums[i] ^ (1 << (j - 1)));
                result.push_back(x);
                found = true;
                break;
            }
            
            // Should theoretically not reach here for primes > 2 based on logic, but for safety
            if(found == false) {
                result.push_back(-1);
            }
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [2, 5]
*
* 1. nums[i] = 2 (Binary 10)
* - condition (nums[i] == 2) is true.
* - push -1.
* - result: [-1]
*
* 2. nums[i] = 5 (Binary 101)
* - Not 2. Enter loop.
* - j = 1: (5 & 10) -> (101 & 010) = 0.
* - Condition ( ... > 0) is false.
* - Found first 0 at j=1.
* - prev bit to flip is j-1 = 0.
* - x = 5 ^ (1 << 0) = 101 ^ 001 = 100 (Decimal 4).
* - push 4. found = true. Break.
* - result: [-1, 4]
*
* Output: [-1, 4]
*
*/

```

---

## üîë Key Insights

1. **Binary Property of `x | (x+1)**`: This operation essentially fills the streak of `1`s starting from the least significant side until it hits a `0`, and turns that `0` into a `1`.
2. **Reversibility**: Since `nums[i]` is the result of such an operation, `nums[i]` must have a sequence of `1`s starting from the LSB. To recover the minimal `x`, we simply need to turn the *last* `1` in that sequence back to a `0`.
3. **Prime Number Characteristic**: All prime numbers (except 2) are odd, meaning their 0-th bit (LSB) is always `1`. This is why we can safely start checking from bit index 1.

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
