# 1266. Minimum Time Visiting All Points

<div align="center">

[<img src="https://img.shields.io/badge/LeetCode-1266._Minimum_Time_Visiting_All_Points-orange?style=for-the-badge&logo=leetcode&logoColor=white" alt="LeetCode Problem Link" />](https://leetcode.com/problems/minimum-time-visiting-all-points/description/)
[<img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge&logo=scale" alt="Difficulty Easy" />](https://leetcode.com/problems/minimum-time-visiting-all-points/description/)

[<img src="https://img.shields.io/badge/Tag-Array-blue?style=for-the-badge" alt="Tag Array" />](https://leetcode.com/tag/array/)
[<img src="https://img.shields.io/badge/Tag-Math-blue?style=for-the-badge" alt="Tag Math" />](https://leetcode.com/tag/math/)
[<img src="https://img.shields.io/badge/Tag-Geometry-blue?style=for-the-badge" alt="Tag Geometry" />](https://leetcode.com/tag/geometry/)

</div>

---

## üìù Problem Statement

On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return *the **minimum time** in seconds to visit all the points in the order given by `points`*.

You can move according to these rules:

1.  In `1` second, you can either:
    * move vertically by one unit,
    * move horizontally by one unit, or
    * move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).
2.  You have to visit the points in the same order as they appear in the array.
3.  You are allowed to pass through points that appear later in the order, but these do not count as visits.

---

## üì∏ Example

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG" alt="Example 1 Image" width="500"/>
</div>

### Example 1:

| Property | Value |
| :--- | :--- |
| **Input** | `points = [[1,1],[3,4],[-1,0]]` |
| **Output** | `7` |
| **Explanation** | One optimal path is `[1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]`.<br>Time from `[1,1]` to `[3,4]` = 3 seconds.<br>Time from `[3,4]` to `[-1,0]` = 4 seconds.<br>Total time = 7 seconds. |

### Example 2:

| Property | Value |
| :--- | :--- |
| **Input** | `points = [[3,2],[-2,2]]` |
| **Output** | `5` |

---

## ‚ö†Ô∏è Constraints

* `points.length == n`
* `1 <= n <= 100`
* `points[i].length == 2`
* `-1000 <= points[i][0], points[i][1] <= 1000`

---

## üß† Approach & Key Insights

The problem asks for the minimum time to traverse a sequence of points in 2D space. The key constraints on movement are that we can move horizontally, vertically, or diagonally.

1.  **Diagonal Movement is Optimal**: A diagonal move allows us to change both X and Y coordinates by 1 unit simultaneously in 1 second. This is always more efficient (or equal) to moving strictly horizontally or vertically if we need to change both coordinates.
2.  **Chebyshev Distance**: The time taken to travel between two points $(x_1, y_1)$ and $(x_2, y_2)$ is determined by the dimension with the larger difference.
    * Let $dx = |x_2 - x_1|$ and $dy = |y_2 - y_1|$.
    * We can move diagonally for $\min(dx, dy)$ steps. This reduces the difference in both dimensions.
    * After the diagonal moves, we are left with a straight line distance of $|dx - dy|$ in one direction (either horizontal or vertical).
    * Total time = Diagonal Steps + Straight Steps
    * Total time = $\min(dx, dy) + |dx - dy|$.
    * Mathematically, this simplifies to $\max(dx, dy)$ (Chebyshev distance).

**Algorithm:**
1.  Initialize `steps` to 0.
2.  Iterate through the `points` array from the first point to the second-to-last point.
3.  For each pair of adjacent points `points[i]` and `points[i+1]`:
    * Calculate absolute difference in X: `dx = abs(points[i+1][0] - points[i][0])`
    * Calculate absolute difference in Y: `dy = abs(points[i+1][1] - points[i][1])`
    * Add the cost to move between them: `min(dx, dy) + abs(dy - dx)` to `steps`.
4.  Return `steps`.

---

## üíª Solution Code

```cpp
// Intuition: To minimize time, we should move diagonally as much as possible because a diagonal move covers 1 unit in both X and Y directions in just 1 second.
// Approach: For each pair of consecutive points, calculate the horizontal (dx) and vertical (dy) distances. The time taken is the calculated by covering the minimum common distance diagonally and the rest straight.
// Time Complexity: O(N) where N is the number of points, as we iterate through the points array once.
// Space Complexity: O(1) as we use only a few variables for storage and no extra data structures.

class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points) {
        
        int n = points.size(); // Total number of points to visit
        int steps = 0; // Accumulator for total seconds

        // Iterate from the first point up to the second to last point
        for(int i = 0; i < n - 1; i++) {
            int x1 = points[i][0];
            int y1 = points[i][1];

            int x2 = points[i + 1][0];
            int y2 = points[i + 1][1];

            int dx = abs(x2 - x1); // Distance in X direction
            int dy = abs(y2 - y1); // Distance in Y direction

            // Add optimal time: diagonal moves (min of dx,dy) + remaining straight moves
            steps += (min(dx, dy) + abs(dy -dx));
        }
        return steps; // Return the total time calculated
    }
};

/*
*
* Dry Run
* Input: points = [[1,1], [3,4], [-1,0]]
*
* Initialization: n = 3, steps = 0
*
* Iteration 1 (i = 0):
* Current Point (x1, y1) = [1, 1]
* Next Point (x2, y2) = [3, 4]
* dx = |3 - 1| = 2
* dy = |4 - 1| = 3
* Diagonal moves = min(2, 3) = 2
* Straight moves = abs(3 - 2) = 1
* Time added = 2 + 1 = 3
* steps = 3
*
* Iteration 2 (i = 1):
* Current Point (x1, y1) = [3, 4]
* Next Point (x2, y2) = [-1, 0]
* dx = |-1 - 3| = 4
* dy = |0 - 4| = 4
* Diagonal moves = min(4, 4) = 4
* Straight moves = abs(4 - 4) = 0
* Time added = 4 + 0 = 4
* steps = 3 + 4 = 7
*
* Loop ends (i < n - 1).
* Return steps = 7.
*/

```

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)

---

## üìÑ License

This repository is released under the [MIT License](LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-time-visiting-all-points/description/) for original content and copyright.**
