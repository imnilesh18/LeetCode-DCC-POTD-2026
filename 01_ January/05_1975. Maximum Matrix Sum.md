# 1975. Maximum Matrix Sum

<div align="center">

[<img src="https://img.shields.io/badge/LeetCode-1975._Maximum_Matrix_Sum-orange?style=for-the-badge&logo=leetcode&logoColor=white" alt="LeetCode Problem Link" />](https://leetcode.com/problems/maximum-matrix-sum/)
[<img src="https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge&logo=scale" alt="Difficulty Medium" />](https://leetcode.com/problems/maximum-matrix-sum/)
[<img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="Language C++" />](https://github.com/imnilesh18)

</div>

---

## üìù Problem Statement

You are given an `n x n` integer `matrix`. You can do the following operation **any** number of times:

- Choose any two **adjacent** elements of `matrix` and **multiply** each of them by `-1`.

Two elements are considered **adjacent** if and only if they share a **border**.

Your goal is to **maximize** the summation of the matrix's elements. Return *the **maximum** sum of the matrix's elements using the operation mentioned above.*

---

## üì∏ Examples

<div align="center">

### Example 1

| Input | Output | Explanation |
| :---: | :---: | :--- |
| `matrix = [[1,-1],[-1,1]]` | `4` | We can follow the following steps to reach sum equals 4:<br>1. Multiply the 2 elements in the first row by -1.<br>2. Multiply the 2 elements in the first column by -1. |

<img src="https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png" alt="Example 1 Image" width="250" />

<br>

### Example 2

| Input | Output | Explanation |
| :---: | :---: | :--- |
| `matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]` | `16` | We can follow the following step to reach sum equals 16:<br>1. Multiply the 2 last elements in the second row by -1. |

<img src="https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png" alt="Example 2 Image" width="250" />

</div>

---

## üö´ Constraints

- `n == matrix.length == matrix[i].length`
- `2 <= n <= 250`
- `-10^5 <= matrix[i][j] <= 10^5`

---

## üí° Key Insights & Approach

### üß† Intuition
The core observation is that the operation allows us to "move" negative signs around the matrix.
1.  If we apply the operation to two adjacent negative numbers `(-a, -b)`, they both become positive `(a, b)`. We essentially eliminated two negative signs.
2.  If we apply the operation to one negative and one positive number `(-a, b)`, they become `(a, -b)`. The negative sign effectively "moves" from one cell to the adjacent one.
3.  Since we can perform this operation any number of times, we can move a negative sign anywhere in the matrix.

### üö∂ Step-by-Step Approach
1.  **Traverse the Matrix**: Iterate through every element of the `n x n` matrix.
2.  **Track Totals**:
    * Calculate the **Total Sum** of the absolute values of all elements (assuming we can turn everything positive).
    * **Count** the number of negative elements found.
    * Find the **Minimum Absolute Value** in the entire matrix. This is crucial for the case where we can't eliminate all negative signs.
3.  **Analyze Negative Count**:
    * **Even Negatives**: If the count of negative numbers is even, we can pair them up and flip them to positive. Or, if they are far apart, we can "move" them adjacent to each other and flip them. Thus, the answer is simply the `Total Sum` of absolute values.
    * **Odd Negatives**: If the count is odd, one negative sign will always remain (we can eliminate pairs, but 1 will be left). To maximize the total sum, we must apply this unavoidable negative sign to the element with the smallest absolute value.
4.  **Calculate Result**:
    * If `countNegatives` is even: return `sum`.
    * If `countNegatives` is odd: return `sum - 2 * smallestAbsoluteValue`.
    *(Why `2 *`? Because `sum` included `+abs(x)`, but the actual value should be `-abs(x)`. The difference between `+x` and `-x` is `2x`.)*

---

## üíª Solution Code

```cpp
// Intuition: Negative signs can be moved or eliminated in pairs. If odd count, minimize loss by sacrificing the smallest absolute value.
// Approach: Sum all absolute values, count negatives, and find min abs value. If negatives are even, return full sum; else subtract 2 * min abs value.
// Time Complexity: O(N^2) - We iterate through the entire n x n matrix once.
// Space Complexity: O(1) - We use only a few variables for tracking sum and counts.

class Solution {
public:
    long long maxMatrixSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        long long sum = 0;
        int countNegatives = 0;
        int smallestAbsoluteValue = INT_MAX;

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                sum += abs(matrix[i][j]); // Add absolute value to total sum
                
                if(matrix[i][j] < 0) {
                    countNegatives++; // Track count of negative numbers
                }

                // Keep track of the element with the smallest magnitude
                smallestAbsoluteValue = min(smallestAbsoluteValue, abs(matrix[i][j]));
            }
        }

        // If even number of negatives, we can make all positive
        if(countNegatives % 2 == 0) {
            return sum;
        }

        // If odd, one number must remain negative (the smallest one)
        // We subtract 2*min because 'sum' added it as positive, but it should be negative
        return sum - 2 * smallestAbsoluteValue;
    }
};

/*
*
* Dry Run
* Input: [[1, 2, 3], [-1, -2, -3], [1, 2, 3]]
* n = 3
* * Iteration:
* [0][0] = 1  -> sum = 1, neg = 0, minAbs = 1
* [0][1] = 2  -> sum = 3, neg = 0, minAbs = 1
* [0][2] = 3  -> sum = 6, neg = 0, minAbs = 1
* [1][0] = -1 -> sum = 7, neg = 1, minAbs = 1
* [1][1] = -2 -> sum = 9, neg = 2, minAbs = 1
* [1][2] = -3 -> sum = 12, neg = 3, minAbs = 1
* [2][0] = 1  -> sum = 13, neg = 3, minAbs = 1
* [2][1] = 2  -> sum = 15, neg = 3, minAbs = 1
* [2][2] = 3  -> sum = 18, neg = 3, minAbs = 1
* * Final State:
* sum = 18
* countNegatives = 3 (Odd)
* smallestAbsoluteValue = 1
* * Result: 
* Since countNegatives is odd:
* return sum - 2 * smallestAbsoluteValue
* return 18 - 2 * 1 = 16
* * Output: 16
*/

```

---

## üìÇ Related Topics

* **Array**
* **Greedy**
* **Matrix**

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-matrix-sum/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)