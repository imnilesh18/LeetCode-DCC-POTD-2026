# 66. Plus One

<div align="center">

|                            ğŸ”— **Problem Link**                             |                         ğŸ’¡ **Difficulty**                         | ğŸ·ï¸ **Tags** |
| :------------------------------------------------------------------------: | :---------------------------------------------------------------: | :---------: |
| [LeetCode - Plus One](https://leetcode.com/problems/plus-one/description/) | ![Easy](https://img.shields.io/badge/Difficulty-Easy-brightgreen) | Array, Math |

</div>

---

## ğŸ“ Problem Statement

You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the $i^{th}$ digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return _the resulting array of digits_.

---

## ğŸ”’ Constraints

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading `0`'s.

---

## ğŸ’» Examples

<details>
<summary>Click to view examples</summary>

| Case  |        Input         |   Output    |                                                           Explanation                                                           |
| :---: | :------------------: | :---------: | :-----------------------------------------------------------------------------------------------------------------------------: |
| **1** |  `digits = [1,2,3]`  |  `[1,2,4]`  |   The array represents the integer 123.<br>Incrementing by one gives 123 + 1 = 124.<br>Thus, the result should be `[1,2,4]`.    |
| **2** | `digits = [4,3,2,1]` | `[4,3,2,2]` | The array represents the integer 4321.<br>Incrementing by one gives 4321 + 1 = 4322.<br>Thus, the result should be `[4,3,2,2]`. |
| **3** |    `digits = [9]`    |   `[1,0]`   |       The array represents the integer 9.<br>Incrementing by one gives 9 + 1 = 10.<br>Thus, the result should be `[1,0]`.       |

</details>

---

## ğŸ§  Approach

### Key Idea

The problem asks us to perform a simple mathematical addition of `1` to a number represented by an array. Since the array length can be up to 100, we cannot convert it to a standard integer type (like `long long`) as it would overflow. We must process the array directly.

### Steps

1.  **Iterate Backwards**: Start from the last digit (Least Significant Digit), just like manual addition.
2.  **Case 1: Digit < 9**: If the current digit is less than 9 (e.g., 0-8), simply add 1 to it. No carry is generated. We can immediately return the updated array.
3.  **Case 2: Digit == 9**: If the digit is 9, adding 1 makes it 10. We set the current digit to `0` and carry over the `1` to the next left digit (next iteration).
4.  **Edge Case (All 9s)**: If the loop finishes and we haven't returned, it means all digits were 9s (e.g., `999` became `000`). We need to insert a `1` at the very beginning to get the final result (e.g., `1000`).

---

## ğŸš€ Solution Code

```cpp
// Intuition: Treat the array as a large integer and perform addition starting from the least significant digit (end of array), handling carries similar to manual addition.
// Approach: Iterate backwards from the last element. If a digit is less than 9, increment it and return immediately. If it's 9, set it to 0 and continue (carrying over 1). If the loop finishes, it means all digits were 9 (e.g., 999 becomes 000), so insert 1 at the beginning to make it 1000.
// Time Complexity: O(n) in the worst case (all 9s), where n is the number of digits.
// Space Complexity: O(1) as we modify the input array in-place (excluding dynamic array resizing).

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n = digits.size();

        // Start from LSB (end of array) like usual math addition
        int i = n - 1;

        while(i >= 0) {
            // If digit is not 9, simply add 1 and return result
            if(digits[i] < 9) {
                digits[i] += 1;
                return digits;
            }

            // else we did get 9
            // 9+1 = 10, so current digit becomes 0 and carry propagates
            digits[i] = 0;
            i--;
        }

        // If loop completes, it means carry forwarded till the end (e.g., 99 -> 00)
        // Insert 1 at the beginning to make it 100
        digits.insert(begin(digits), 1);

        return digits;
    }
};

/*
*
* Dry Run
*
* Example 1: digits = [1, 2, 9]
* n = 3, i starts at 2.
*
* Iteration 1 (i=2):
* - digits[2] is 9. It is NOT < 9.
* - Set digits[2] = 0. Array is now [1, 2, 0].
* - Decrement i to 1.
*
* Iteration 2 (i=1):
* - digits[1] is 2. 2 < 9 is TRUE.
* - Increment digits[1] to 3. Array is now [1, 3, 0].
* - Return [1, 3, 0]. Result correct (129 + 1 = 130).
*
* Example 2: digits = [9, 9]
* n = 2, i starts at 1.
*
* Iteration 1 (i=1):
* - digits[1] is 9. Set digits[1] = 0. Array: [9, 0]. i = 0.
*
* Iteration 2 (i=0):
* - digits[0] is 9. Set digits[0] = 0. Array: [0, 0]. i = -1.
*
* Loop Ends (i = -1).
* - Insert 1 at beginning. Array: [1, 0, 0].
* - Return [1, 0, 0]. Result correct (99 + 1 = 100).
*
*/
```

---

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/plus-one/description/) for original content and copyright.**
