# 2977. Minimum Cost to Convert String II

<div align="center">

[![Time Complexity](https://img.shields.io/badge/Time%20Complexity-O(M%20log%20L%20%2B%20N%C2%B2L%20%2B%20M%C2%B2(V%2BE)logV)-blue?style=for-the-badge&logo=clock)](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)
[![Space Complexity](https://img.shields.io/badge/Space%20Complexity-O(M%C2%B2%20%2B%20V%20%2B%20E%20%2B%20N)-blue?style=for-the-badge&logo=memory)](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Hard-red?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)
[![Platform](https://img.shields.io/badge/Platform-LeetCode-orange?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)
[![Language](https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B)](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)

</div>

---

## üîó Problem Link

[**LeetCode: 2977. Minimum Cost to Convert String II**](https://leetcode.com/problems/minimum-cost-to-convert-string-ii)

---

## üí° Problem Statement

You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.

You start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` if **there exists** any **index** `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:

1.  The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` or `d < a`. In other words, the indices picked in both operations are **disjoint**.
2.  The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` and `b == d`. In other words, the indices picked in both operations are **identical**.

Return *the **minimum** cost to convert the string* `source` *to the string* `target` *using **any** number of operations*. If it is impossible to convert `source` to `target`, return `-1`.

**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.

---

## üõë Constraints

-   `1 <= source.length == target.length <= 1000`
-   `source`, `target` consist only of lowercase English characters.
-   `1 <= cost.length == original.length == changed.length <= 100`
-   `1 <= original[i].length == changed[i].length <= source.length`
-   `original[i]`, `changed[i]` consist only of lowercase English characters.
-   `original[i] != changed[i]`
-   `1 <= cost[i] <= 10^6`

---

## üß™ Examples

### Example 1

| Input | Output | Explanation |
| :--- | :---: | :--- |
| **source** = "abcd"<br>**target** = "acbe"<br>**original** = ["a","b","c","c","e","d"]<br>**changed** = ["b","c","b","e","b","e"]<br>**cost** = [2,5,5,1,2,20] | **28** | Change `source[1..1]` ("b" -> "c") cost 5.<br>Change `source[2..2]` ("c" -> "e") cost 1.<br>Change `source[2..2]` ("e" -> "b") cost 2.<br>Change `source[3..3]` ("d" -> "e") cost 20.<br>Total = 5 + 1 + 2 + 20 = 28. |

### Example 2

| Input | Output | Explanation |
| :--- | :---: | :--- |
| **source** = "abcdefgh"<br>**target** = "acdeeghh"<br>**original** = ["bcd","fgh","thh"]<br>**changed** = ["cde","thh","ghh"]<br>**cost** = [1,3,5] | **9** | Change `source[1..3]` ("bcd" -> "cde") cost 1.<br>Change `source[5..7]` ("fgh" -> "thh") cost 3.<br>Change `source[5..7]` ("thh" -> "ghh") cost 5.<br>Total = 1 + 3 + 5 = 9. |

### Example 3

| Input | Output | Explanation |
| :--- | :---: | :--- |
| **source** = "abcdefgh"<br>**target** = "addddddd"<br>**original** = ["bcd","defgh"]<br>**changed** = ["ddd","ddddd"]<br>**cost** = [100,1578] | **-1** | Impossible to convert `source` to `target` due to overlapping constraints. |

---

## üß† Approach & Key Insights

The problem asks for the minimum cost to transform one string into another using substring replacement rules. Since operations must be disjoint (or identical replacement), this structure suggests a **Dynamic Programming** approach combined with **Shortest Path Algorithms**.

### 1. Dynamic Programming (The Structure)
We need to make decisions at each index `i` of the `source` string:
-   **Match Character:** If `source[i] == target[i]`, we can potentially move to `i+1` with **0 cost**.
-   **Replace Substring:** We can try to replace a substring starting at `i` of length `len` (i.e., `source[i...i+len-1]`) with the corresponding substring in `target` (i.e., `target[i...i+len-1]`).
-   **State:** `dp[i]` represents the minimum cost to convert the suffix `source[i...n-1]` to `target[i...n-1]`.

### 2. Graph & Shortest Path (The Cost Calculation)
The conversion rules (`original[j]` -> `changed[j]` with `cost[j]`) form a directed graph where nodes are substrings.
-   Since conversions can be chained (e.g., "ab" -> "xy" -> "pq"), finding the cost to convert a specific substring `S` to `T` is equivalent to finding the shortest path from node `S` to node `T` in this graph.
-   **Dijkstra's Algorithm** is ideal for finding this minimum cost because edge weights are non-negative.

### 3. Optimizations (Crucial for Hard Constraints)
-   **Valid Lengths Only:** Instead of trying every possible substring length from index `i`, we only try lengths that actually exist in the `original` rules array. We store these lengths in a `set`.
-   **Memoized Dijkstra:** We might need to find the cost from Substring A to Substring B multiple times. We cache (memoize) the results of Dijkstra's algorithm to avoid re-computation.
-   **Adjacency List:** Since nodes are strings, we use an `unordered_map<string, vector<pair<string, long long>>>` to represent the graph.

### 4. Algorithm Flow
1.  Build the graph (adjacency list) from `original`, `changed`, and `cost`.
2.  Store all unique lengths of `original` strings in a `set`.
3.  Define a recursive function `solve(idx)` with memoization (`dpMemo`):
    -   Base Case: If `idx >= n`, cost is 0.
    -   Option 1: If `source[idx] == target[idx]`, consider `solve(idx + 1)`.
    -   Option 2: Iterate through all `len` in `validLengths`. Extract `subSource` and `subTarget`. Use Dijkstra to find the min cost to convert `subSource` -> `subTarget`. If possible, add this cost to `solve(idx + len)` and minimize the result.
4.  Return the result of `solve(0)`.

---

## üíª Solution Code

```cpp
// Intuition: The problem requires partitioning the string and converting segments. This hints at DP. Since conversions can be chained (A->B->C), finding the min cost for a segment is a Shortest Path problem (Dijkstra) on a graph of substrings.
// Approach: Build a graph where nodes are substrings. Use DP to traverse the source string. At each index, try matching the character or replacing valid substrings. Use Dijkstra (memoized) to calculate replacement costs.
// Time Complexity: O(M log L + N^2 * L + M^2 * (V + E) log V) where N is string length, M is rules, L is unique lengths, V unique substrings.
// Space Complexity: O(M^2 + V + E + N) for graph, memoization tables, and recursion stack.

/*
N = length of sourceStr / targetStr
M = number of conversion rules (original.size())
L = number of distinct substring lengths (L = lengthSet.size())
V = number of unique strings appearing in original and changed
E = number of edges in graph (E = M)
*/

class Solution {
public:
    typedef long long ll;
    typedef pair<ll, string> P;
    ll BIG_VALUE = 1e10; // Represents infinity
    unordered_map<string, vector<pair<string, ll>>> adj; // Graph: string -> {neighbor, cost}

    // Memoization for Dijkstra: start_node -> (end_node -> min_cost)
    unordered_map<string, unordered_map<string, ll>> dijkstraMemo;

    // Memoization for DP: index -> min_cost
    vector<ll> dpMemo;

    string sourceStr;
    string targetStr;
    set<int> validLengths; // Stores lengths of substrings present in rules
    
    // Dijkstra to find min cost to convert 'start' string to 'end' string
    ll dijkstra(string& start, string& end) {
        // Return cached result if available
        if(dijkstraMemo[start].count(end)) {
            return dijkstraMemo[start][end];
        }

        // Min-heap for Dijkstra: {cost, string_node}
        priority_queue<P, vector<P>, greater<P>> pq;
        unordered_map<string, ll> result; // Stores min cost from 'start' to any node
        
        result[start] = 0;
        pq.push({0, start});

        while(!pq.empty()) {
            ll currCost = pq.top().first;
            string node = pq.top().second;
            pq.pop();

            // Optimization: Stop if we reached the target node
            if(node == end) {
                break; 
            }
            
            // Optimization: If current path is worse than known path, skip
            if (result.count(node) && currCost > result[node]) continue;

            for(auto &edge : adj[node]) {
                string adjNode = edge.first;
                ll edgeCost = edge.second;

                // Relaxation step
                if(!result.count(adjNode) || currCost + edgeCost < result[adjNode]) {
                    result[adjNode] = currCost + edgeCost;
                    pq.push({currCost+edgeCost, adjNode});
                }
            }
        }

        ll finalCost = result.count(end) ? result[end] : BIG_VALUE;
        return dijkstraMemo[start][end] = finalCost; // Store and return
    }

    // DP Function: Min cost to convert source[idx...] to target[idx...]
    ll solve(int idx) {
        if(idx >= sourceStr.length())
            return 0; // Base case: end of string
        if(dpMemo[idx] != -1)
            return dpMemo[idx]; // Return memoized DP state

        ll minCost = BIG_VALUE;

        // Option 1: If characters match, we can potentially skip conversion
        if(sourceStr[idx] == targetStr[idx])
            minCost = solve(idx+1);
        
        // Option 2: Try converting substrings starting at idx
        for(auto &len : validLengths) {
            if(idx + len > sourceStr.length()) {
                break; // Stop if length exceeds remaining string
            }

            string srcSub = sourceStr.substr(idx, len);
            string tgtSub = targetStr.substr(idx, len);

            // If source substring has no conversion rules, skip
            if(!adj.count(srcSub)) {
                continue;
            }

            // Find min cost to convert srcSub to tgtSub using Dijkstra
            ll minPathCost = dijkstra(srcSub, tgtSub);
            
            // If conversion impossible, skip
            if(minPathCost == BIG_VALUE)
                continue;
            
            // Recurse for the rest of the string
            ll remainingCost = solve(idx + len);
            if (remainingCost != BIG_VALUE) {
                 minCost = min(minCost, minPathCost + remainingCost);
            }
        }

        return dpMemo[idx] = minCost;
    }

    long long minimumCost(string source, string target, vector<string>& original, vector<string>& changed, vector<int>& cost) {
        sourceStr = source;
        targetStr = target;

        // Initialize DP memoization table
        dpMemo.assign(10001, -1);

        // Build Graph
        for(int i = 0; i < original.size(); i++) {
            adj[original[i]].push_back({changed[i], cost[i]});
        }

        // Store unique lengths for optimization
        for(auto &s : original) {
            validLengths.insert(s.length());
        }

        ll result = solve(0);

        return result == BIG_VALUE ? -1 : result;
    }
};

/*
*
* Dry Run Example: 
* source = "abcd", target = "acbe"
* Rules: "b"->"c"(5), "c"->"e"(1), "e"->"b"(2), "d"->"e"(20)
*
* solve(0) ['a']:
* 'a' == 'a'. Recursive call solve(1).
*
* solve(1) ['b']:
* 'b' != 'c'. Must swap substring.
* Try len=1 ("b"):
* dijkstra("b", "c") -> "b"->"c" cost 5.
* Recursive call solve(2).
*
* solve(2) ['c']:
* 'c' != 'b'. Must swap substring.
* Try len=1 ("c"):
* dijkstra("c", "b") -> "c"->"e"(1) -> "e"->"b"(2). Total cost 3.
* Recursive call solve(3).
*
* solve(3) ['d']:
* 'd' != 'e'. Must swap substring.
* Try len=1 ("d"):
* dijkstra("d", "e") -> "d"->"e" cost 20.
* Recursive call solve(4).
*
* solve(4):
* Base case, returns 0.
*
* Unwinding:
* solve(3) returns 20 + 0 = 20.
* solve(2) returns 3 + 20 = 23.
* solve(1) returns 5 + 23 = 28.
* solve(0) returns 28.
* * Result: 28
*/

```

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-cost-to-convert-string-ii) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
