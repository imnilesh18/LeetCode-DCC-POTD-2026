# 1161. Maximum Level Sum of a Binary Tree

- **Problem Link**: [Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/)
- **Difficulty**: Medium
- **Tags**: `Tree`, `Breadth-First Search`, `Depth-First Search`, `Binary Tree`

## üóíÔ∏è Problem Statement

Given the `root` of a binary tree, the level of its root is `1`, the level of its children is `2`, and so on.

Return the **smallest** level `x` such that the sum of all the values of nodes at level `x` is **maximal**.

---

## üì∏ Examples

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2019/05/03/capture.JPG" alt="Example 1" width="400"/>
</div>

### Example 1
| Input | Output | Explanation |
| :--- | :--- | :--- |
| `root = [1,7,0,7,-8,null,null]` | `2` | **Level 1 sum** = 1.<br>**Level 2 sum** = 7 + 0 = 7.<br>**Level 3 sum** = 7 + -8 = -1.<br>We return the level with the maximum sum which is level 2. |

### Example 2
| Input | Output |
| :--- | :--- |
| `root = [989,null,10250,98693,-89388,null,null,null,-32127]` | `2` |

---

## üîç Constraints

- The number of nodes in the tree is in the range `[1, 10‚Å¥]`.
- `-10‚Åµ <= Node.val <= 10‚Åµ`

---

## üí° Approach

The problem asks us to find the level in a binary tree where the sum of node values is maximized. If there's a tie, we must return the smallest level number. This suggests a need to traverse the tree and aggregate values based on their depth.

### 1. Breadth-First Search (BFS)
BFS is the most natural fit for "level-based" problems.
- We traverse the tree level by level using a queue.
- For each level, we calculate the sum of all node values currently in the queue.
- We maintain a `maxSum` and `resultLevel`.
- If the current level's sum is strictly greater than `maxSum`, we update our record. Since we process levels in increasing order (1, 2, 3...), ignoring ties (using `>`) ensures we keep the smallest level index.

### 2. Depth-First Search (DFS)
We can also solve this by traversing the tree recursively.
- We need a way to store the sum for each level. A Hash Map (or a `std::map` in C++ which keeps keys sorted) is perfect for this, mapping `Level -> Sum`.
- During the DFS traversal, we pass the `currentLevel` as an argument.
- For every node, we add its value to the corresponding entry in the map: `map[currentLevel] += node.val`.
- After the traversal is complete, we iterate through the map to find the level with the highest sum.

---

## üíª Solution Code

### Approach 1: BFS (Level Order Traversal)

```cpp
// Intuition: BFS naturally processes nodes level by level, allowing us to compute the sum of each level directly and compare it with the running maximum.
// Approach: Use a Queue for level-order traversal. For each level, compute the sum. Update the result level if the current sum is strictly greater than the maximum found so far.
// Time Complexity: O(N) where N is the number of nodes, as we visit each node exactly once.
// Space Complexity: O(W) where W is the maximum width of the tree (max number of nodes in a level), used by the queue.

class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        int maxSum = INT_MIN;       // Initialize max sum to smallest integer
        int resultLevel = 0;        // To store the answer
        int currLevel = 1;          // Start from level 1
        
        queue<TreeNode*> que;
        que.push(root);             // Push root to kickstart BFS
        
        
        while(!que.empty()) {

            int n = que.size();     // Number of nodes in the current level
            
            int sum = 0;            // Accumulator for current level sum
            
            while(n--) {            // Process all nodes at this level
                
                TreeNode* node = que.front();
                que.pop();
                
                sum += node->val;   // Add node value to level sum
                
                // Add children to queue for next level
                if(node->left)
                    que.push(node->left);
                
                if(node->right)
                    que.push(node->right);
            }
            
            // Check if current level sum is the new maximum
            // Use strictly greater (>) to maintain smallest level on ties
            if(sum > maxSum) {
                maxSum = sum;
                resultLevel = currLevel;
            }
            currLevel++;            // Move to next level
        }
        
        return resultLevel;
        
    }
};

/*
*
* Dry Run
* Input: root = [1, 7, 0]
*
* Queue: [1]
* Level 1: Pop 1. Sum = 1. MaxSum updates to 1. ResultLevel = 1. Queue: [7, 0].
*
* Level 2: Pop 7, Pop 0. Sum = 7+0 = 7. 
* Sum (7) > MaxSum (1). MaxSum updates to 7. ResultLevel = 2. Queue: [].
*
* Queue empty. Return 2.
*
*/
```

### Approach 2: DFS (Recursion with Map)

```cpp
// Intuition: We can traverse the tree in any order (Preorder here) as long as we track the depth. A map can effectively aggregate sums for each depth.
// Approach: Use DFS to traverse the tree. Maintain a map[level] -> sum. Add node values to their respective level keys. Finally, iterate the map to find the max sum.
// Time Complexity: O(N) to visit all nodes + O(H) to iterate the map (where H is height). Overall O(N).
// Space Complexity: O(H) for recursion stack and map storage.

class Solution {
public:
    
    map<int, int> mp; // Map to store sum for each level: {Level -> Sum}
    
    void DFS(TreeNode* root, int currLevel) {
        
        if(!root)
            return;
        
        // Add current node's value to the sum of its level
        mp[currLevel] += root->val;
        
        // Recurse for children with incremented level
        DFS(root->left, currLevel+1);
        DFS(root->right, currLevel+1);
        
    }
    
    int maxLevelSum(TreeNode* root) {
        mp.clear();     // Ensure map is clean
        
        DFS(root, 1);   // Start DFS from root at level 1
        
        int maxSum = INT_MIN;
        int result = 0;
        
        // Iterate through the map (std::map keeps keys sorted by level)
        for(auto &it : mp) {
            
            int level = it.first;
            int sum   = it.second;
            
            // Update only if we find a strictly greater sum
            // This preserves the smallest level for ties
            if(sum > maxSum) {
                maxSum = sum;
                result = level;
            }
            
        }
        
        return result;
    }
};

/*
*
* Dry Run
* Input: root = [1, 7, 0]
*
* DFS(1, level 1): mp[1] += 1. Calls DFS(7, 2), DFS(0, 2).
* DFS(7, level 2): mp[2] += 7.
* DFS(0, level 2): mp[2] += 0.
* Map State: {1: 1, 2: 7}
*
* Loop Map:
* Level 1, Sum 1: MaxSum = 1, Result = 1.
* Level 2, Sum 7: 7 > 1 -> MaxSum = 7, Result = 2.
*
* Return 2.
*
*/
```

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)