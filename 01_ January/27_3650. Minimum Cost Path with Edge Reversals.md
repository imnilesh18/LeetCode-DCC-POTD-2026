# 3650. Minimum Cost Path with Edge Reversals

<p align="center">
  <a href="https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/">
    <img src="https://img.shields.io/badge/LeetCode-3650-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 3650">
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Medium">
  <img src="https://img.shields.io/badge/C++-Solution-blue?style=for-the-badge&logo=c%2B%2B" alt="C++">
</p>

## üìå Problem Statement

You are given a directed, weighted graph with $n$ nodes labeled from $0$ to $n - 1$, and an array `edges` where `edges[i] = [ui, vi, wi]` represents a directed edge from node $u_i$ to node $v_i$ with cost $w_i$.

Each node $u_i$ has a **switch** that can be used **at most once**: when you arrive at $u_i$ and have not yet used its switch, you may activate it on one of its **incoming edges** $v_i \to u_i$, reverse that edge to $u_i \to v_i$, and **immediately** traverse it.

The reversal is only valid for that single move, and using a reversed edge costs $2 \times w_i$.

Return the **minimum** total cost to travel from node $0$ to node $n - 1$. If it is not possible, return `-1`.

### üñºÔ∏è Example Visualization

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2025/05/07/e1drawio.png" alt="Graph Example" width="500">
</p>

## üîê Constraints

- $2 \le n \le 5 \times 10^4$
- $1 \le \text{edges.length} \le 10^5$
- $\text{edges}[i] = [u_i, v_i, w_i]$
- $0 \le u_i, v_i \le n - 1$
- $1 \le w_i \le 1000$

## üìù Examples

| Example | Input | Output | Explanation |
|:---:|:---:|:---:|:---|
| **1** | `n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]` | `5` | **Path:** $0 \to 1$ (cost 3).<br>At node 1, reverse the original edge $3 \to 1$ into $1 \to 3$ and traverse it at cost $2 \times 1 = 2$.<br>**Total:** $3 + 2 = 5$. |
| **2** | `n = 4, edges = [[0,2,1],[2,1,1],[1,3,1],[2,3,3]]` | `3` | No reversal needed.<br>**Path:** $0 \to 2$ (cost 1) $\to 1$ (cost 1) $\to 3$ (cost 1).<br>**Total:** $1 + 1 + 1 = 3$. |

## üí° Approach

The problem asks for the minimum cost to reach node $n-1$ from node $0$ in a weighted directed graph, with a twist: we can reverse incoming edges at a cost of twice their original weight.

### Key Insights

1.  **Modeling as a Shortest Path Problem**: Since all edge weights are non-negative, this is a classic shortest path problem that can be solved using **Dijkstra's Algorithm**.
2.  **Graph Transformation**:
    * For every given directed edge $u \to v$ with weight $w$, we can traverse it normally. So, add a directed edge $u \to v$ with weight $w$ to our adjacency list.
    * The "switch" allows us to reverse an incoming edge. If there is an edge $u \to v$ in the input, it is incoming to $v$. If we are at $v$, we can reverse it to go back to $u$. The cost for this is $2 \times w$. Therefore, we add a directed edge $v \to u$ with weight $2w$ to our adjacency list.
3.  **Dijkstra's Execution**:
    * We use a priority queue (min-heap) to explore paths with the smallest accumulated cost first.
    * Maintain a `result` array (initialized to infinity) to track the minimum cost to reach each node.
    * Start from source node $0$ with cost $0$.
    * If we extract node $n-1$ from the priority queue, the current cost is guaranteed to be the minimum cost.

This approach effectively flattens the "switch" logic into a static graph where every original edge effectively creates a bi-directional connection with different weights for forward vs. backward traversal.

## üíª Solution Code

```cpp
// Intuition: The problem can be modeled as a shortest path problem on a graph where traversing an edge normally costs 'w' and traversing it in reverse (using the switch) costs '2*w'.
// Approach: Build an adjacency list where for every edge u->v with weight w, add a forward edge u->v with weight w and a backward edge v->u with weight 2*w. Then run Dijkstra's algorithm.
// Time Complexity: O(E * log V) where E is the number of edges and V is the number of nodes, due to Dijkstra's algorithm using a Priority Queue.
// Space Complexity: O(V + E) to store the graph in an adjacency list and for the distance array/priority queue.

class Solution {
public:
    typedef pair<int, int> P;

    int minCost(int n, vector<vector<int>>& edges) {
        unordered_map<int, vector<P>> adj;

        // Build the graph with both forward and reverse edges
        for(auto &edge :edges) {
            int u = edge[0];
            int v = edge[1];
            int wt = edge[2];

            adj[u].push_back({v, wt});        // Normal edge cost
            adj[v].push_back({u, 2 *wt});     // Reversed edge cost
        }

        priority_queue<P, vector<P>, greater<P>> pq; // Min-heap for Dijkstra
        vector<int> result(n, INT_MAX); // result[i] = shortest distance from source 0 to node i
        
        result[0] = 0;
        pq.push({0, 0}); // Push {distance, node}

        while(!pq.empty()) {
            int d = pq.top().first;
            int node = pq.top().second;
            pq.pop();

            // If we reached the target node, return the cost
            if(node == n - 1) {
                return result[n - 1];
            }
            
            // If current path is worse than already found, skip
            if(d > result[node]) continue;

            for(auto &p : adj[node]) {
                int adjNode = p.first;
                int dist = p.second;

                // Relaxation step
                if(d + dist < result[adjNode]) {
                    result[adjNode] = d + dist;
                    pq.push({d + dist, adjNode});
                }
            }
        }
        return -1;
    }
};

/*
*
* Dry Run
* Input: n = 4, edges = [[0,1,3],[3,1,1],[2,3,4],[0,2,2]]
* * Graph Construction:
* 0 -> 1 (wt: 3), 1 -> 0 (wt: 6)
* 3 -> 1 (wt: 1), 1 -> 3 (wt: 2) [Reversed edge from 3->1]
* 2 -> 3 (wt: 4), 3 -> 2 (wt: 8)
* 0 -> 2 (wt: 2), 2 -> 0 (wt: 4)
*
* Initialization:
* result = [0, INF, INF, INF], pq = {(0, 0)}
*
* Iteration 1:
* Pop (0, 0). Node 0.
* Neighbors: 
* 1: Cost 0+3=3. result[1]=3. Push (3, 1)
* 2: Cost 0+2=2. result[2]=2. Push (2, 2)
* pq = {(2, 2), (3, 1)}
*
* Iteration 2:
* Pop (2, 2). Node 2.
* Neighbors:
* 3: Cost 2+4=6. result[3]=6. Push (6, 3)
* 0: Cost 2+4=6. 6 > result[0](0). Ignore.
* pq = {(3, 1), (6, 3)}
*
* Iteration 3:
* Pop (3, 1). Node 1.
* Neighbors:
* 0: Cost 3+6=9. Ignore.
* 3: Cost 3+2=5. 5 < result[3](6). result[3]=5. Push (5, 3)
* pq = {(5, 3), (6, 3)}
*
* Iteration 4:
* Pop (5, 3). Node 3.
* Node is n-1 (3). Return result[3] which is 5.
*
* Output: 5
*/
```

## üîç Further Exploration

- **Why Dijkstra?** Since edge weights represent costs and are strictly positive (weights are $\ge 1$), Dijkstra guarantees the shortest path.
- **Why not BFS?** BFS works for unweighted graphs (or equal weights). Here, weights vary ($w$ vs $2w$), so BFS is not applicable.
- **Alternative:** Bellman-Ford or SPFA could work but are slower ($O(VE)$ vs $O(E \log V)$). Given constraints $V \le 5 \times 10^4$, Dijkstra is optimal.

## üè∑Ô∏è Tags

`Graph` `Dijkstra` `Shortest Path` `Heap (Priority Queue)` `C++`

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)